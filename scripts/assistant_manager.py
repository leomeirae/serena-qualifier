#!/usr/bin/env python3
"""
OpenAI Assistant Manager for Serena Energia Lead Qualification System

This module manages the OpenAI Assistant creation and retrieval for the 
serena-qualifier project. It implements a singleton pattern for Assistant 
management, ensuring consistent configuration and avoiding duplicate creation.

Author: Serena-Coder AI Agent
Version: 1.0.0
Created: 2025-01-17
"""

import os
import sys
import json
import logging
from pathlib import Path
from typing import Optional, Dict, Any
from openai import OpenAI
from openai.types.beta import Assistant
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class AssistantManager:
    """
    Manager class for OpenAI Assistant operations.
    
    Handles creation, retrieval, and configuration of the Serena Energy
    sales specialist assistant with proper knowledge base and tools.
    """
    
    def __init__(self):
        """Initialize the AssistantManager with OpenAI client."""
        self.api_key = os.getenv('OPENAI_API_KEY')
        if not self.api_key:
            raise ValueError("OPENAI_API_KEY environment variable is required")
        
        self.client = OpenAI(api_key=self.api_key)
        # Reason: Use /app/ path for Kestra container environment compatibility
        self.assistant_id_file = Path("/app/assistant_id.txt") if os.path.exists("/app") else Path("assistant_id.txt")
        self.knowledge_base_path = Path("knowledge_base")
        
    def _get_serena_sales_prompt(self) -> str:
        """
        Load the specialized sales prompt for Serena Energy assistant.
        Updated for GPT-4o Vision capabilities, removing OCR dependencies.
        
        Returns:
            str: The comprehensive system prompt for the assistant
        """
        # Try to load from external file first
        prompt_file = os.path.join(os.path.dirname(__file__), 'serena_agent', 'prompts', 'assistant_sales_prompt.txt')
        
        if os.path.exists(prompt_file):
            try:
                with open(prompt_file, 'r', encoding='utf-8') as f:
                    return f.read().strip()
            except Exception as e:
                logger.warning(f"Could not load prompt from file: {e}")
        
        # Fallback to embedded prompt (updated for GPT-4o Vision)
        return """Voc√™ √© a **Serena**, uma assistente virtual especializada em vendas da empresa **SRna Energia**. Sua miss√£o √© **ajudar leads interessados a entender, qualificar e contratar o servi√ßo de energia limpa e mais barata da Serena**, de forma consultiva, clara e emp√°tica.

## AN√ÅLISE DE IMAGENS
**Quando o usu√°rio enviar uma imagem, analise-a diretamente usando sua capacidade de 'vision'. Assuma que √© uma conta de energia e extraia as seguintes informa√ß√µes em um formato JSON:**
```json
{
  "nome_titular": "...",
  "valor_total": "...",
  "consumo_kwh": "...",
  "distribuidora": "...",
  "endereco": "..."
}
```
**Ap√≥s a extra√ß√£o, use esses dados para continuar a conversa de qualifica√ß√£o de forma natural, comentando sobre os valores encontrados.**

## üß≠ Contexto e Miss√£o da Empresa
A SRna Energia √© uma empresa de Gera√ß√£o Distribu√≠da Compartilhada. Ela gera energia solar em fazendas pr√≥prias e converte isso em **cr√©ditos de energia** que s√£o aplicados diretamente na conta de luz dos clientes, proporcionando **descontos garantidos**, **sem necessidade de obras ou instala√ß√£o**, e com **ades√£o 100% digital**.

## üßë‚Äçüíº Seu Papel
Voc√™ atua como **vendedora digital da Serena**, com os seguintes objetivos:
1. Esclarecer d√∫vidas sobre o funcionamento do servi√ßo;
2. Qualificar leads com base em crit√©rios de consumo e titularidade da conta;
3. Processar automaticamente imagens de contas de luz via OCR;
4. Confirmar a elegibilidade do lead e, se qualificado, encaminh√°‚Äëlo para o time de consultores humanos.

## üß∞ Ferramentas √† Sua Disposi√ß√£o
- `query_serena_api` ‚Äî Verifica √°rea de cobertura, planos e promo√ß√µes dispon√≠veis.
- `save_and_fetch_conversation` ‚Äî Busca e registra hist√≥rico de conversas no Supabase.
- `rag_tool` ‚Äî Responde d√∫vidas recorrentes com base na base de conhecimento oficial.

## üß† Regras de Qualifica√ß√£o
- Consumo m√≠nimo recomendado: **R$ 200,00/m√™s** (ideal a partir de R$ 500).
- Titular da conta de luz deve ser o mesmo que assinar√° o contrato.
- Unidade consumidora deve estar dentro da √°rea de cobertura da Serena.

## ‚úÖ Argumentos de Vendas Exemplos
- "Voc√™ n√£o precisa instalar nada na sua casa. Toda energia vem das nossas fazendas solares e √© abatida direto na sua conta."
- "Voc√™ continuar√° recebendo sua conta da distribuidora, mas ela vir√° com desconto. A Serena envia um segundo boleto j√° com valor reduzido. A soma dos dois √© sempre menor que sua conta atual."
- "Nosso processo √© 100% digital, sem burocracia e sem visitas t√©cnicas."

## üõ°Ô∏è Tratamento de Obje√ß√µes
- "E se eu me mudar de endere√ßo?" ‚Üí "Sem problemas, fazemos transfer√™ncia enquanto for na mesma √°rea de concess√£o da distribuidora."
- "Se minha conta for abaixo de R$ 200?" ‚Üí "Neste momento nosso modelo exige R$ 200 m√≠nimos para viabilizar a economia, mas podemos entrar em contato quando seu consumo subir."
- "Como sei que √© confi√°vel?" ‚Üí "Somos regulamentados pela ANEEL (Lei 14.300/2022) e temos centenas de clientes satisfeitos."
- "E se quiser cancelar?" ‚Üí "Nosso contrato √© transparente, com processo de cancelamento simples descrito em contrato."

## ü§ñ Estilo e Tom
- Emp√°tico, consultivo e educativo.
- Use linguagem simples, sem jarg√µes t√©cnicos.
- Insira emojis de forma moderada para humanizar (por exemplo: ‚úÖ, üí°, üìä).
- Sempre proponha pr√≥ximos passos claros antes de encerrar a intera√ß√£o.

## ‚ùó Instru√ß√µes Especiais
1. Ao detectar mensagem com imagem de conta de luz, analise diretamente com sua capacidade de vision.
2. Use `query_serena_api` para confirmar cobertura geogr√°fica e planos.
3. Salve cada intera√ß√£o via `save_and_fetch_conversation` no Supabase.
4. Caso o lead n√£o seja qualificado, explique por que ("consumo abaixo de R$ 200" ou "fora de √°rea de cobertura") e ofere√ßa um canal de recontato futuro.
5. **N√£o** invente dados ‚Äî apoie‚Äëse apenas na base de conhecimento e nas respostas do `rag_tool`.

## üõë Limites
- N√£o prometa economia exata sem an√°lise detalhada da fatura.
- N√£o finalize ou confirme ades√£o; direcione sempre ao time comercial.
- Cite a regulamenta√ß√£o ANEEL (Resolu√ß√£o 482/2012 e Lei 14.300/2022) ao falar de legalidade, mas **n√£o** fa√ßa promessas jur√≠dicas.

---
Pronto para come√ßar a atender seus leads!"""

    def _get_assistant_config(self) -> Dict[str, Any]:
        """
        Get the configuration for creating the OpenAI Assistant.
        
        Returns:
            Dict[str, Any]: Configuration parameters for assistant creation
        """
        return {
            "name": "Serena Sales Specialist",
            "description": "Assistente virtual da SRna Energia para qualifica√ß√£o de leads",
            "instructions": self._get_serena_sales_prompt(),
            "model": "gpt-4o",
            "tools": [
                {"type": "retrieval"},  # For RAG functionality with knowledge base
                {
                    "type": "function", 
                    "function": {
                        "name": "query_serena_api",
                        "description": "Query Serena API for coverage, plans and pricing information",
                        "parameters": {
                            "type": "object",
                            "properties": {
                                "city": {
                                    "type": "string",
                                    "description": "City name to check coverage"
                                },
                                "state": {
                                    "type": "string", 
                                    "description": "State abbreviation (e.g., SP, RJ, MG)"
                                },
                                "action": {
                                    "type": "string",
                                    "enum": ["check_coverage", "get_plans", "calculate_savings"],
                                    "description": "Type of API query to perform"
                                }
                            },
                            "required": ["city", "state", "action"]
                        }
                    }
                },
                {
                    "type": "function",
                    "function": {
                        "name": "rag_tool",
                        "description": "Responder d√∫vidas recorrentes usando a base de conhecimento FAQ da Serena",
                        "parameters": {
                            "type": "object", 
                            "properties": {
                                "query": {
                                    "type": "string",
                                    "description": "Pergunta ou termo de busca na base de conhecimento"
                                }
                            },
                            "required": ["query"]
                        }
                    }
                },
                {
                    "type": "function",
                    "function": {
                        "name": "save_and_fetch_conversation",
                        "description": "Registrar e recuperar hist√≥rico de conversas no Supabase",
                        "parameters": {
                            "type": "object",
                            "properties": {
                                "phone_number": {
                                    "type": "string",
                                    "description": "N√∫mero de telefone do lead (+5581...)"
                                },
                                "action": {
                                    "type": "string",
                                    "enum": ["save_message", "get_history", "update_lead_status"],
                                    "description": "A√ß√£o a ser executada no Supabase"
                                },
                                "message": {
                                    "type": "string",
                                    "description": "Mensagem a ser salva (quando action=save_message)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status do lead (quando action=update_lead_status)"
                                }
                            },
                            "required": ["phone_number", "action"]
                        }
                    }
                }
            ],
            "temperature": 0.7,
            "top_p": 1.0
        }

    def get_or_create_assistant(self) -> str:
        """
        Get existing assistant ID or create a new one.
        
        This function implements the core logic specified in the task:
        1. Check if assistant_id.txt exists
        2. If yes, return the stored ID
        3. If no, create new assistant and save ID
        
        Returns:
            str: The OpenAI Assistant ID
            
        Raises:
            Exception: If assistant creation fails
        """
        logger.info("Starting get_or_create_assistant process")
        
        # Check if assistant_id.txt exists
        if self.assistant_id_file.exists():
            try:
                assistant_id = self.assistant_id_file.read_text().strip()
                logger.info(f"Found existing assistant ID: {assistant_id}")
                
                # Verify the assistant still exists in OpenAI
                try:
                    assistant = self.client.beta.assistants.retrieve(assistant_id)
                    logger.info(f"Verified assistant exists: {assistant.name}")
                    return assistant_id
                except Exception as verify_error:
                    logger.warning(f"Stored assistant ID invalid: {verify_error}")
                    # Continue to create new assistant
                    
            except Exception as read_error:
                logger.error(f"Error reading assistant_id.txt: {read_error}")
                # Continue to create new assistant
        
        # Create new assistant
        logger.info("Creating new OpenAI assistant")
        try:
            config = self._get_assistant_config()
            assistant = self.client.beta.assistants.create(**config)
            
            # Save the assistant ID
            self.assistant_id_file.write_text(assistant.id)
            logger.info(f"Created and saved new assistant: {assistant.id}")
            
            return assistant.id
            
        except Exception as create_error:
            logger.error(f"Failed to create assistant: {create_error}")
            raise Exception(f"Assistant creation failed: {create_error}")

    def get_assistant_info(self, assistant_id: str) -> Optional[Assistant]:
        """
        Get detailed information about an assistant.
        
        Args:
            assistant_id (str): The OpenAI Assistant ID
            
        Returns:
            Optional[Assistant]: Assistant object or None if not found
        """
        try:
            assistant = self.client.beta.assistants.retrieve(assistant_id)
            return assistant
        except Exception as e:
            logger.error(f"Error retrieving assistant info: {e}")
            return None

    def update_assistant(self, assistant_id: str, **kwargs) -> Optional[Assistant]:
        """
        Update an existing assistant configuration.
        
        Args:
            assistant_id (str): The OpenAI Assistant ID
            **kwargs: Parameters to update
            
        Returns:
            Optional[Assistant]: Updated assistant object or None if failed
        """
        try:
            assistant = self.client.beta.assistants.update(assistant_id, **kwargs)
            logger.info(f"Updated assistant: {assistant_id}")
            return assistant
        except Exception as e:
            logger.error(f"Error updating assistant: {e}")
            return None

    def delete_assistant(self, assistant_id: str) -> bool:
        """
        Delete an assistant and clean up local files.
        
        Args:
            assistant_id (str): The OpenAI Assistant ID
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            self.client.beta.assistants.delete(assistant_id)
            
            # Remove local assistant_id.txt file
            if self.assistant_id_file.exists():
                self.assistant_id_file.unlink()
                
            logger.info(f"Deleted assistant: {assistant_id}")
            return True
            
        except Exception as e:
            logger.error(f"Error deleting assistant: {e}")
            return False


def main():
    """
    Main function for command-line usage.
    
    This allows the script to be run directly from Kestra workflows
    or command line for testing purposes.
    """
    try:
        manager = AssistantManager()
        assistant_id = manager.get_or_create_assistant()
        
        # Output for Kestra workflow consumption
        result = {
            "assistant_id": assistant_id,
            "status": "success",
            "message": f"Assistant ready: {assistant_id}"
        }
        
        print(json.dumps(result))
        return assistant_id
        
    except Exception as e:
        error_result = {
            "assistant_id": None,
            "status": "error", 
            "message": f"Failed to get/create assistant: {str(e)}"
        }
        
        print(json.dumps(error_result), file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main() 