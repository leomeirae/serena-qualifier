id: 2_sdr_conversation_flow_updated
namespace: serena.production
description: "Serena SDR - Agente Virtual de Pré-vendas (Sílvia) - Workflow principal de conversação"

triggers:
  - id: whatsapp_sdr_trigger
    type: io.kestra.plugin.core.trigger.Webhook
    key: converse_sdr_silvia
    description: "Webhook para mensagens WhatsApp do agente SDR"

variables:
  # Configurações IA
  ai_model: "gpt-4o"
  max_tokens: 1500
  temperature: 0.5
  
  # Configurações de Performance
  context_size_limit: 102400
  max_retries: 3
  request_timeout: 30

  # URLs dos MCP Servers
  supabase_mcp_url: "http://supabase-mcp-server:3000"
  serena_mcp_url: "http://serena-mcp-server:3002"
  whatsapp_mcp_url: "http://whatsapp-mcp-server:3003"

tasks:
  # FASE 1: LOG INICIAL E VALIDAÇÃO
  - id: log_inicial
    type: io.kestra.plugin.core.log.Log
    description: "Registra início do processamento da mensagem"
    message: |
      [SDR TRIGGER] Webhook recebido
      ================================================
      Timestamp: {{ now() }}
      
      [DEBUG] Workflow iniciado com sucesso!

  # FASE 2: EXTRAÇÃO DE DADOS DO WEBHOOK WHATSAPP
  - id: extract_whatsapp_data
    type: io.kestra.plugin.scripts.python.Script
    description: "Extrai dados do webhook WhatsApp e busca lead no Supabase"
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: kestra-agent:latest
      networkMode: coolify
    env:
      TRIGGER_BODY: "{{ trigger.body | toJson | default('{}') }}"
      MANUAL_PHONE: "{{ inputs.phone | default('') }}"
      MANUAL_MESSAGE: "{{ inputs.message | default('') }}"
      MANUAL_TYPE: "{{ inputs.type | default('text') }}"
      DB_CONNECTION_STRING: "{{ secret('DB_CONNECTION_STRING') }}"
    script: |
      import json
      import os
      import psycopg2
      from kestra import Kestra
      
      print("[DEBUG] Iniciando extração de dados do webhook WhatsApp...")
      
      try:
          # Obter dados do trigger ou inputs manuais
          trigger_body = json.loads(os.environ.get('TRIGGER_BODY', '{}'))
          manual_phone = os.environ.get('MANUAL_PHONE', '')
          manual_message = os.environ.get('MANUAL_MESSAGE', '')
          manual_type = os.environ.get('MANUAL_TYPE', 'text')
          
          print(f"[DEBUG] Trigger body: {json.dumps(trigger_body, indent=2)}")
          print(f"[DEBUG] Manual inputs: phone={manual_phone}, message={manual_message}, type={manual_type}")
          
          # Extrair dados do webhook WhatsApp ou inputs manuais
          phone_number = None
          message_text = None
          message_type = "text"
          media_id = ""
          
          # Se temos inputs manuais, usar eles
          if manual_phone and manual_message:
              phone_number = manual_phone
              message_text = manual_message
              message_type = manual_type
              print(f"[DEBUG] Usando inputs manuais")
          # Tentar extrair do formato padrão primeiro
          elif 'phone' in trigger_body:
              phone_number = trigger_body['phone']
              message_text = trigger_body.get('message', '')
              message_type = trigger_body.get('type', 'text')
              print(f"[DEBUG] Usando formato padrão do trigger")
          # Se não, tentar extrair do formato WhatsApp webhook
          elif 'entry' in trigger_body and len(trigger_body['entry']) > 0:
              entry = trigger_body['entry'][0]
              if 'changes' in entry and len(entry['changes']) > 0:
                  change = entry['changes'][0]
                  if 'value' in change:
                      value = change['value']
                      
                      # Extrair telefone
                      if 'contacts' in value and len(value['contacts']) > 0:
                          phone_number = value['contacts'][0].get('wa_id', '')
                          if phone_number and not phone_number.startswith('+'):
                              phone_number = '+' + phone_number
                      
                      # Extrair mensagem
                      if 'messages' in value and len(value['messages']) > 0:
                          message = value['messages'][0]
                          message_type = message.get('type', 'text')
                          
                          if message_type == 'text':
                              message_text = message.get('text', {}).get('body', '')
                          elif message_type == 'image':
                              message_text = message.get('image', {}).get('caption', '')
                              media_id = message.get('image', {}).get('id', '')
                          elif message_type == 'document':
                              message_text = message.get('document', {}).get('caption', '')
                              media_id = message.get('document', {}).get('id', '')
              print(f"[DEBUG] Usando formato WhatsApp webhook")
          
          print(f"[DEBUG] Phone: {phone_number}")
          print(f"[DEBUG] Message: {message_text}")
          print(f"[DEBUG] Type: {message_type}")
          print(f"[DEBUG] Media ID: {media_id}")
          
          # Validar dados obrigatórios
          if not phone_number:
              raise ValueError("Phone number not found in webhook or inputs")
          
          if not message_text:
              raise ValueError("Message text not found in webhook or inputs")
          
          # Buscar lead no Supabase
          db_connection_string = os.getenv('DB_CONNECTION_STRING')
          if not db_connection_string:
              raise ValueError("DB_CONNECTION_STRING not found")
          
          conn = psycopg2.connect(db_connection_string)
          cur = conn.cursor()
          
          # Buscar lead pelo número de telefone
          cur.execute("""
              SELECT id, name, phone_number, city, state, invoice_amount, client_type
              FROM leads 
              WHERE phone_number = %s
              ORDER BY created_at DESC
              LIMIT 1
          """, (phone_number,))
          
          result = cur.fetchone()
          cur.close()
          conn.close()
          
          if result:
              lead_id, lead_name, lead_phone, lead_city, lead_state, lead_invoice, lead_type = result
              print(f"[DEBUG] Lead encontrado: ID={lead_id}, Name={lead_name}")
          else:
              # Se não encontrar, criar um lead temporário
              lead_id = f"temp_{phone_number.replace('+', '').replace('-', '')}"
              lead_name = "Lead WhatsApp"
              lead_city = "N/A"
              lead_state = "N/A"
              lead_invoice = 0
              lead_type = "casa"
              print(f"[DEBUG] Lead não encontrado, usando ID temporário: {lead_id}")
          
          print("[DEBUG] Dados extraídos com sucesso")
          
          Kestra.outputs({
              'phone': phone_number,
              'lead_id': str(lead_id),
              'lead_name': lead_name,
              'lead_city': lead_city,
              'lead_state': lead_state,
              'lead_invoice': float(lead_invoice) if lead_invoice else 0,
              'lead_type': lead_type,
              'message_text': message_text,
              'message_type': message_type,
              'media_id': media_id,
              'extraction_success': True
          })
          
      except Exception as e:
          print(f"[ERROR] Erro ao extrair dados: {str(e)}")
          import traceback
          print(f"[ERROR] Traceback: {traceback.format_exc()}")
          
          # Fallback com dados mínimos
          Kestra.outputs({
              'phone': '+5581997498268',  # Fallback para seu número
              'lead_id': 'ERROR',
              'lead_name': 'Erro',
              'lead_city': 'N/A',
              'lead_state': 'N/A',
              'lead_invoice': 0,
              'lead_type': 'casa',
              'message_text': 'Erro na extração',
              'message_type': 'text',
              'media_id': '',
              'extraction_success': False
          })

  # FASE 3: CLASSIFICAÇÃO DE MÍDIA
  - id: classify_media
    type: io.kestra.plugin.scripts.python.Script
    description: "Classifica se a mensagem é imagem ou texto"
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: kestra-agent:latest
      networkMode: coolify
    env:
      MEDIA_ID: "{{ outputs.extract_whatsapp_data.vars.media_id }}"
      MESSAGE_TYPE: "{{ outputs.extract_whatsapp_data.vars.message_type }}"
      MESSAGE_TEXT: "{{ outputs.extract_whatsapp_data.vars.message_text }}"
    script: |
      import os
      import json
      from kestra import Kestra
      
      try:
          media_id = os.environ.get('MEDIA_ID', '')
          message_type = os.environ.get('MESSAGE_TYPE', 'text')
          message_text = os.environ.get('MESSAGE_TEXT', '')
          
          print(f"[DEBUG] Classificando mídia: media_id={media_id}, type={message_type}")
          
          # Lógica simples de classificação
          if not media_id or media_id.strip() == "":
              is_image = False
              confidence = 1.0
              extracted_text = message_text
          elif message_type == "image":
              is_image = True
              confidence = 0.9
              extracted_text = ""
          elif message_type == "text":
              is_image = False
              confidence = 1.0
              extracted_text = message_text
          else:
              is_image = False
              confidence = 0.8
              extracted_text = message_text
          
          print(f"[DEBUG] Classificação: is_image={is_image}, confidence={confidence}")
          
          Kestra.outputs({
              'is_image': is_image,
              'confidence': confidence,
              'extracted_text': extracted_text,
              'media_id': media_id,
              'message_type': message_type
          })
          
      except Exception as e:
          print(f"[ERROR] Erro na classificação de mídia: {str(e)}")
          import traceback
          print(f"[ERROR] Traceback: {traceback.format_exc()}")
          Kestra.outputs({
              'is_image': False,
              'confidence': 0.0,
              'extracted_text': '',
              'media_id': media_id,
              'message_type': message_type
          })

  # FASE 4: PROCESSAMENTO DO AGENTE IA
  - id: run_agent
    type: io.kestra.plugin.scripts.python.Script
    description: "Executa o agente conversacional com OpenAI Function Calling"
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: kestra-agent:latest
      networkMode: coolify
    env:
      # 🔐 Chaves Secretas (API)
      OPENAI_API_KEY: "{{ secret('OPENAI_API_KEY') }}"
      SERENA_API_TOKEN: "{{ secret('SERENA_API_TOKEN') }}"
      WHATSAPP_API_TOKEN: "{{ secret('WHATSAPP_API_TOKEN') }}"

      # 🧠 Configuração da Mensagem
      USER_MESSAGE: "{{ outputs.extract_whatsapp_data.vars.message_text }}"
      PHONE_NUMBER: "{{ outputs.extract_whatsapp_data.vars.phone }}"
      MESSAGE_TYPE: "{{ outputs.extract_whatsapp_data.vars.message_type }}"
      MEDIA_ID: "{{ outputs.extract_whatsapp_data.vars.media_id | default('') }}"
      LEAD_ID: "{{ outputs.extract_whatsapp_data.vars.lead_id }}"
      LEAD_NAME: "{{ outputs.extract_whatsapp_data.vars.lead_name }}"
      LEAD_CITY: "{{ outputs.extract_whatsapp_data.vars.lead_city }}"
      LEAD_STATE: "{{ outputs.extract_whatsapp_data.vars.lead_state }}"
      LEAD_INVOICE: "{{ outputs.extract_whatsapp_data.vars.lead_invoice }}"
      IS_IMAGE: "{{ outputs.classify_media.vars.is_image | default(false) }}"
      EXTRACTED_TEXT: "{{ outputs.classify_media.vars.extracted_text | default('') }}"

      # 🔗 Banco de Dados (PostgreSQL centralizado)
      DB_CONNECTION_STRING: "{{ secret('DB_CONNECTION_STRING') }}"

      # 🌐 Serviços Internos
      SERENA_API_BASE_URL: "https://partnership-service-staging.api.srna.co"
      REDIS_URL: "redis://redis:6379/0"
      PYTHONPATH: "/app"

    inputFiles:
      scripts/agent_orchestrator.py: "{{ read('scripts/agent_orchestrator.py') }}"
      scripts/agent_tools/knowledge_base_tool.py: "{{ read('scripts/agent_tools/knowledge_base_tool.py') }}"
      scripts/agent_tools/faq_data.py: "{{ read('scripts/agent_tools/faq_data.py') }}"
      scripts/agent_tools/serena_tools.py: "{{ read('scripts/agent_tools/serena_tools.py') }}"
      scripts/agent_tools/supabase_agent_tools.py: "{{ read('scripts/agent_tools/supabase_agent_tools.py') }}"
      scripts/lead_data_utils.py: "{{ read('scripts/lead_data_utils.py') }}"
      scripts/__init__.py: "{{ read('scripts/__init__.py') }}"
      scripts/agent_tools/__init__.py: "{{ read('scripts/agent_tools/__init__.py') }}"

    script: |
      import sys
      sys.path.insert(0, '/app')
      import os
      import logging
      import base64
      from kestra import Kestra
      
      # Configurar logging
      logging.basicConfig(level=logging.INFO)
      logger = logging.getLogger(__name__)
      
      # Configuração das variáveis Supabase (decodificação base64)
      supabase_url = os.environ.get('SUPABASE_URL')
      supabase_key = os.environ.get('SUPABASE_KEY')
      
      # Decodificação base64 se necessário
      if supabase_url and supabase_url.startswith("aHR0c"):
          try:
              supabase_url = base64.b64decode(supabase_url).decode("utf-8")
              logger.info("[DEBUG] SUPABASE_URL decodificado com sucesso")
          except Exception as e:
              logger.error(f"[ERROR] Falha ao decodificar SUPABASE_URL: {e}")
      
      if supabase_key and supabase_key.startswith("ZXlKa"):
          try:
              supabase_key = base64.b64decode(supabase_key).decode("utf-8")
              logger.info("[DEBUG] SUPABASE_KEY decodificado com sucesso")
          except Exception as e:
              logger.error(f"[ERROR] Falha ao decodificar SUPABASE_KEY: {e}")
      
      # Configura as variáveis para uso
      if supabase_url and supabase_key:
          os.environ['SUPABASE_URL'] = supabase_url
          os.environ['SUPABASE_KEY'] = supabase_key
          logger.info("[DEBUG] SUPABASE_URL e SUPABASE_KEY configurados para Storage API")
      else:
          logger.warning("[WARNING] SUPABASE_URL ou SUPABASE_KEY não encontrados - usando PostgreSQL direto")
      
      try:
          import warnings
          warnings.filterwarnings("ignore", category=UserWarning)
          from scripts.agent_orchestrator import handle_agent_invocation
          
          phone_number = os.environ.get('PHONE_NUMBER')
          user_message = os.environ.get('USER_MESSAGE')
          message_type = os.environ.get('MESSAGE_TYPE', 'text')
          media_id = os.environ.get('MEDIA_ID', '')
          lead_name = os.environ.get('LEAD_NAME', 'Cliente')
          lead_city = os.environ.get('LEAD_CITY', 'N/A')
          
          # Log detalhado para debug
          logger.info(f"[DEBUG] MEDIA_ID do ENV: '{media_id}'")
          logger.info(f"[DEBUG] MESSAGE_TYPE do ENV: '{message_type}'")
          logger.info(f"[DEBUG] PHONE_NUMBER do ENV: '{phone_number}'")
          logger.info(f"[DEBUG] USER_MESSAGE do ENV: '{user_message[:100]}...'")
          logger.info(f"[DEBUG] LEAD_NAME do ENV: '{lead_name}'")
          logger.info(f"[DEBUG] LEAD_CITY do ENV: '{lead_city}'")
          
          logger.info(f"[AI] Processando mensagem para {phone_number}: {user_message[:50]}... (type={message_type}, media_id={media_id})")
          result = handle_agent_invocation(phone_number, user_message, lead_city=lead_city, lead_name=lead_name, message_type=message_type, media_id=media_id)
          response = result.get('response', 'Desculpe, ocorreu um erro interno.')
          logger.info(f"[AI] Resposta gerada: {len(response)} chars")
          
          Kestra.outputs({
              'response': response,
              'success': True,
              'lead_id': os.environ.get('LEAD_ID'),
              'phone_number': phone_number,
              'lead_name': lead_name
          })
      except Exception as e:
          logger.error(f"[ERROR] Erro no processamento IA: {str(e)}")
          import traceback
          logger.error(f"[ERROR] Traceback: {traceback.format_exc()}")
          
          fallback_response = "Olá! Sou a Sílvia da Serena Energia. 😊 No momento estou com dificuldades técnicas. Por favor, tente novamente em alguns minutos ou entre em contato conosco pelo nosso canal oficial. Obrigada pela compreensão!"
          Kestra.outputs({
              'response': fallback_response,
              'success': False,
              'error': str(e),
              'lead_id': os.environ.get('LEAD_ID'),
              'phone_number': phone_number
          })

  # FASE 5: ENVIO DA RESPOSTA VIA WHATSAPP
  - id: send_whatsapp_message
    type: io.kestra.plugin.core.http.Request
    description: "Envia resposta do agente via WhatsApp MCP (JSON-RPC)"
    uri: "{{ vars.whatsapp_mcp_url }}/mcp"
    method: POST
    headers:
      Content-Type: "application/json"
    body: |
      {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "tools/call",
        "params": {
          "name": "sendTextMessage",
          "arguments": {
            "to": "{{ outputs.extract_whatsapp_data.vars.phone }}",
            "message": "{{ outputs.run_agent.vars.response }}"
          }
        }
      }
    allowFailure: true

  # FASE 6: LOG DE SUCESSO
  - id: log_success
    type: io.kestra.plugin.core.log.Log
    description: "Registra sucesso do processamento"
    runIf: "{{ outputs.run_agent.vars.success == true }}"
    message: |
      ✅ SDR PROCESSAMENTO CONCLUÍDO COM SUCESSO
      ================================================
      Lead ID: {{ outputs.extract_whatsapp_data.vars.lead_id }}
      Lead Name: {{ outputs.extract_whatsapp_data.vars.lead_name }}
      Phone: {{ outputs.extract_whatsapp_data.vars.phone }}
      Message: {{ outputs.extract_whatsapp_data.vars.message_text[:100] }}...
      Is Image: {{ outputs.classify_media.vars.is_image }}
      Response Length: {{ outputs.run_agent.vars.response | length }} chars
      WhatsApp Status: {{ outputs.send_whatsapp_message.vars.statusCode | default('PENDING') }}
      Timestamp: {{ now() }}

  # FASE 7: LOG FINAL
  - id: log_final
    type: io.kestra.plugin.core.log.Log
    description: "Log final do workflow"
    message: |
      [SDR WORKFLOW FINALIZADO]
      ================================================
      Lead ID: {{ outputs.extract_whatsapp_data.vars.lead_id }}
      Lead Name: {{ outputs.extract_whatsapp_data.vars.lead_name }}
      Phone: {{ outputs.extract_whatsapp_data.vars.phone }}
      Agent Success: {{ outputs.run_agent.vars.success | default('N/A') }}
      WhatsApp Sent: {{ outputs.send_whatsapp_message.vars.statusCode | default('N/A') }}
      Duration: {{ execution.duration }}
      Timestamp: {{ now() }}

# Error Handling Global
errors:
  - id: global_error_handler
    type: io.kestra.plugin.core.log.Log
    description: "Handler global de erros"
    level: ERROR
    message: |
      ❌ ERRO GLOBAL NO WORKFLOW SDR
      ================================================
      Lead ID: {{ outputs.extract_whatsapp_data.vars.lead_id | default('N/A') }}
      Phone: {{ outputs.extract_whatsapp_data.vars.phone | default('N/A') }}
      Error: {{ execution.error }}
      Task: {{ execution.taskRunId }}
      Timestamp: {{ now() }}
      
      Enviando mensagem de fallback para o lead... 

  - id: send_fallback_message
    type: io.kestra.plugin.core.http.Request
    description: "Envia mensagem de fallback em caso de erro"
    uri: "{{ vars.whatsapp_mcp_url }}/mcp"
    method: POST
    headers:
      Content-Type: "application/json"
    body: |
      {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "tools/call",
        "params": {
          "name": "sendTextMessage",
          "arguments": {
            "to": "{{ outputs.extract_whatsapp_data.vars.phone | default('+5581997498268') }}",
            "message": "Desculpe, tivemos um problema técnico. Retornarei em breve. 😊"
          }
        }
      } 