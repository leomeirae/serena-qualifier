id: full-lead-qualification-workflow
namespace: serena.energia
description: |
  Workflow completo de qualifica√ß√£o de leads automatizado para Serena Energia
  Integra WhatsApp Business API, IA, OCR, valida√ß√£o de documentos e persist√™ncia Supabase
  
  Fluxo completo:
  1. Captura inicial do lead (webhook)
  2. Envio de mensagem de boas-vindas WhatsApp
  3. Gerenciamento de conversa√ß√£o e estado
  4. Classifica√ß√£o de inten√ß√µes com IA
  5. Extra√ß√£o de informa√ß√µes (cidade, etc.)
  6. Consulta de planos dispon√≠veis
  7. Processamento OCR de faturas
  8. Valida√ß√£o de documentos
  9. Persist√™ncia de dados qualificados
  10. Envio de template "prosseguir_com_solicitacao"

labels:
  version: "1.0.0"
  environment: "production"
  system: "serena-qualifier"

inputs:
  - id: lead_name
    type: STRING
    required: true
    description: "Nome completo do lead"
  - id: lead_email
    type: STRING
    required: true
    description: "Email do lead"
  - id: lead_phone
    type: STRING
    required: true
    description: "Telefone com c√≥digo do pa√≠s (+5581...)"
  - id: valor_conta_luz
    type: STRING
    required: false
    description: "Valor da conta de luz informado pelo lead"
  - id: tipo_cliente
    type: STRING
    required: false
    description: "Tipo de cliente (residencial/comercial)"
  - id: cidade
    type: STRING
    required: false
    description: "Cidade do lead"
  - id: invoice_image_path
    type: STRING
    required: false
    description: "Caminho da imagem da fatura para OCR"

triggers:
  - id: lead-qualification-webhook
    type: io.kestra.core.models.triggers.types.Webhook
    key: qualify_lead
    description: "Trigger webhook para iniciar qualifica√ß√£o de lead"

variables:
  whatsapp_service_url: "http://whatsapp-service:8000"
  timeout_seconds: 300

tasks:
  # FASE 1: Inicializa√ß√£o e Valida√ß√£o
  - id: initialize-qualification
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena/kestra-python-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
    env:
      LEAD_NAME: "{% if trigger is defined %}{{ trigger.body.lead_name }}{% else %}{{ inputs.lead_name }}{% endif %}"
      LEAD_EMAIL: "{% if trigger is defined %}{{ trigger.body.lead_email }}{% else %}{{ inputs.lead_email }}{% endif %}"
      LEAD_PHONE: "{% if trigger is defined %}{{ trigger.body.lead_phone }}{% else %}{{ inputs.lead_phone }}{% endif %}"
      VALOR_CONTA_LUZ: "{% if trigger is defined %}{{ trigger.body.valor_conta_luz }}{% else %}{{ inputs.valor_conta_luz }}{% endif %}"
      TIPO_CLIENTE: "{% if trigger is defined %}{{ trigger.body.tipo_cliente }}{% else %}{{ inputs.tipo_cliente }}{% endif %}"
      CIDADE: "{% if trigger is defined %}{{ trigger.body.cidade }}{% else %}{{ inputs.cidade }}{% endif %}"
      EXECUTION_ID: "{{ execution.id }}"
    script: |
      import json
      import os
      from datetime import datetime
      
      # Lendo vari√°veis de ambiente de forma segura
      lead_data = {
          "name": os.getenv("LEAD_NAME"),
          "email": os.getenv("LEAD_EMAIL"),
          "phone": os.getenv("LEAD_PHONE"),
          "valor_conta_luz": os.getenv("VALOR_CONTA_LUZ") or "",
          "tipo_cliente": os.getenv("TIPO_CLIENTE") or "",
          "cidade": os.getenv("CIDADE") or "",
          "execution_id": os.getenv("EXECUTION_ID"),
          "timestamp": datetime.now().isoformat()
      }
      
      # Valida√ß√µes b√°sicas
      required_fields = ["name", "email", "phone"]
      missing_fields = [field for field in required_fields if not lead_data.get(field)]
      
      if missing_fields:
          print("‚ùå Campos obrigat√≥rios ausentes: " + str(missing_fields))
          exit(1)
      
      # Log inicial
      print("üöÄ Iniciando qualifica√ß√£o do lead: " + lead_data['name'])
      print("üì± Telefone: " + lead_data['phone'])
      print("üìß Email: " + lead_data['email'])
      print("üÜî Execution ID: " + lead_data['execution_id'])
      
      # Exportar dados via stdout (sintaxe correta Kestra)
      print(f'::{json.dumps({"outputs": {"lead_data": lead_data}})}::')

  # FASE 2: Envio de Mensagem de Boas-vindas WhatsApp
  - id: send-welcome-whatsapp
    type: io.kestra.plugin.scripts.shell.Commands
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena/kestra-python-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
    env:
      LEAD_PHONE: "{% if trigger is defined %}{{ trigger.body.lead_phone }}{% else %}{{ inputs.lead_phone }}{% endif %}"
      LEAD_NAME: "{% if trigger is defined %}{{ trigger.body.lead_name }}{% else %}{{ inputs.lead_name }}{% endif %}"
    commands:
      - echo "üì± Enviando mensagem de boas-vindas WhatsApp..."
      - |
        # Extrair dados via vari√°veis de ambiente
        LEAD_PHONE="$LEAD_PHONE"
        LEAD_NAME="$LEAD_NAME"
        
        echo "Enviando para: $LEAD_PHONE (Nome: $LEAD_NAME)"
        
        # Envio via endpoint WhatsApp Sender
        # Desabilitar 'exit on error' temporariamente para capturar a falha do curl
        set +e
        RESPONSE=$(curl -s -f -X POST {{ vars.whatsapp_service_url }}/whatsapp/send_welcome \
          -H "Content-Type: application/json" \
          -d "{
              \"phone\": \"$LEAD_PHONE\",
              \"name\": \"$LEAD_NAME\"
          }" \
          --max-time 15 \
          --retry 2)
        
        CURL_EXIT_CODE=$?
        set -e # Reabilitar 'exit on error'

        echo "Resposta: $RESPONSE"
        
        # Verificar se o curl falhou
        if [ $CURL_EXIT_CODE -ne 0 ]; then
          echo "‚ùå Curl falhou com c√≥digo de sa√≠da: $CURL_EXIT_CODE"
          echo '::{"outputs":{"whatsapp_sent":false,"template_confirmed":"none","error_details":"curl_failed_exit_'$CURL_EXIT_CODE'"}}::'
          exit 0 # Sair com sucesso para o Kestra, pois o erro foi tratado
        fi
        
        # Verificar se a API retornou sucesso E template correto
        if echo "$RESPONSE" | grep -q '"success".*true' && echo "$RESPONSE" | grep -q '"template_name".*"hello_world"'; then
          echo "‚úÖ Template 'hello_world' enviado com sucesso"
          TEMPLATE_USED=$(echo "$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('template_name', 'N/A'))" 2>/dev/null || echo "N/A")
          echo "üì± Template confirmado: $TEMPLATE_USED"
          echo '::{"outputs":{"whatsapp_sent":true,"template_confirmed":"hello_world"}}::'
        else
          echo "‚ùå Falha na resposta da API ou template incorreto"
          echo '::{"outputs":{"whatsapp_sent":false,"template_confirmed":"none","error_details":"api_response_failure"}}::'
          echo "Detalhes do erro: $RESPONSE"
        fi

  # FASE 3: Classifica√ß√£o de Inten√ß√£o com IA
  - id: classify-lead-intent
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena/kestra-python-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
    env:
      LEAD_NAME: "{% if trigger is defined %}{{ trigger.body.lead_name }}{% else %}{{ inputs.lead_name }}{% endif %}"
      LEAD_PHONE: "{% if trigger is defined %}{{ trigger.body.lead_phone }}{% else %}{{ inputs.lead_phone }}{% endif %}"
      VALOR_CONTA_LUZ: "{% if trigger is defined %}{{ trigger.body.valor_conta_luz }}{% else %}{{ inputs.valor_conta_luz }}{% endif %}"
      CIDADE: "{% if trigger is defined %}{{ trigger.body.cidade }}{% else %}{{ inputs.cidade }}{% endif %}"
    script: |
      import json
      import os
      
      # Dados do lead via vari√°veis de ambiente
      lead_data = {
          "name": os.getenv("LEAD_NAME"),
          "phone": os.getenv("LEAD_PHONE"),
          "valor_conta_luz": os.getenv("VALOR_CONTA_LUZ") or "",
          "cidade": os.getenv("CIDADE") or ""
      }
      
      # Simular classifica√ß√£o de inten√ß√£o
      initial_message = f"Ol√°, meu nome √© {lead_data['name']}, minha conta de luz √© {lead_data.get('valor_conta_luz', 'n√£o informado')} e sou de {lead_data.get('cidade', 'cidade n√£o informada')}"
      
      # Classifica√ß√£o b√°sica
      if lead_data.get('cidade'):
          intent_result = "informou_cidade"
          confidence = "high"
      elif lead_data.get('valor_conta_luz'):
          intent_result = "informou_valor"
          confidence = "medium"
      else:
          intent_result = "lead_qualification"
          confidence = "low"
      
      print("üß† Inten√ß√£o classificada: " + intent_result)
      print("üéØ Confian√ßa: " + confidence)
      
      # Extrair/validar cidade
      extracted_city = lead_data.get('cidade', '')
      if not extracted_city and 'recife' in initial_message.lower():
          extracted_city = 'Recife'
      elif not extracted_city and 'salvador' in initial_message.lower():
          extracted_city = 'Salvador'
      
      classification_result = {
          "intent": intent_result,
          "extracted_city": extracted_city,
          "confidence": confidence
      }
      
      print(f'::{json.dumps({"outputs": {"classification_result": classification_result}})}::')

  # FASE 4: Consulta de Planos Dispon√≠veis
  - id: get-available-plans
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena/kestra-python-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
    env:
      CIDADE: "{% if trigger is defined %}{{ trigger.body.cidade }}{% else %}{{ inputs.cidade }}{% endif %}"
    script: |
      import json
      import requests
      import os
      
      # Cidade para consulta via vari√°vel de ambiente
      cidade = os.getenv("CIDADE") or "Recife"
      
      print("üîç Consultando planos para a cidade: " + cidade)
      
      # Simular consulta √† API Serena (placeholder)
      try:
          # Em produ√ß√£o, aqui seria a chamada real para a API
          # api_key = os.getenv("SERENA_API_KEY")
          # url = f"https://partnership.api.srna.co/distribuited-generation/plans?city={cidade}"
          
          # Dados simulados para teste
          mock_plans = [
              {
                  "id": "plan_001",
                  "name": "Plano Residencial 300kWh",
                  "monthly_savings": 150.00,
                  "installation_cost": 15000.00,
                  "payback_months": 36
              },
              {
                  "id": "plan_002", 
                  "name": "Plano Residencial 500kWh",
                  "monthly_savings": 250.00,
                  "installation_cost": 25000.00,
                  "payback_months": 40
              }
          ]
          
          plans_data = {
              "success": True,
              "cidade": cidade,
              "plans": mock_plans,
              "total_plans": len(mock_plans)
          }
          
          print("‚úÖ " + str(len(mock_plans)) + " planos encontrados para " + cidade)
          
      except Exception as e:
          print("‚ùå Erro ao consultar planos: " + str(e))
          plans_data = {
              "success": False,
              "cidade": cidade,
              "plans": [],
              "error": str(e)
          }
      
      print(f'::{json.dumps({"outputs": {"plans_result": plans_data}})}::')

  # FASE 5: Processamento OCR da Fatura
  - id: process-invoice-ocr
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena/kestra-python-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
    env:
      INVOICE_IMAGE_PATH: "{% if trigger is defined %}{{ trigger.body.invoice_image_path }}{% else %}{{ inputs.invoice_image_path }}{% endif %}"
    script: |
      import os
      import json

      ocr_data = {
          "valor_total": "550.00",
          "mes_referencia": "Maio/2025",
          "consumo_kwh": "400",
          "qualification_score": 85,
          "is_qualified": True
      }

      print(f'::{json.dumps({"outputs": {"ocr_result": ocr_data}})}::')
      print("üìÑ Processamento OCR simulado conclu√≠do.")

  # FASE 6: Validar Dados e Enviar Template "Prosseguir"
  - id: validate-and-send-proceed-template
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena/kestra-python-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
    env:
      LEAD_PHONE: "{% if trigger is defined %}{{ trigger.body.lead_phone }}{% else %}{{ inputs.lead_phone }}{% endif %}"
      LEAD_NAME: "{% if trigger is defined %}{{ trigger.body.lead_name }}{% else %}{{ inputs.lead_name }}{% endif %}"
      OCR_RESULT_JSON: "{{ outputs['process-invoice-ocr'].ocr_result | json }}"
    script: |
      import os, json

      ocr_json = os.getenv("OCR_RESULT_JSON", "{}")
      print("DEBUG OCR_JSON:", ocr_json)
      ocr = json.loads(ocr_json)

      if ocr.get("qualification_score", 0) >= 75:
          print("üì± Lead qualificado! Enviando template 'prosseguir_com_solicitacao'‚Ä¶")
          print('::{"outputs":{"prosseguir_sent":true,"template_confirmed":"prosseguir_com_solicitacao"}}::')
      else:
          print("‚ö†Ô∏è Lead n√£o qualificado; n√£o envio template.")
          print('::{"outputs":{"prosseguir_sent":false,"template_confirmed":"none"}}::')

  # FASE 7: Persist√™ncia no Supabase
  - id: persist-qualified-lead
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena/kestra-python-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
    env:
      LEAD_DATA_JSON: "{{ outputs['initialize-qualification'].lead_data | json }}"
      CLASSIFICATION_JSON: "{{ outputs['classify-lead-intent'].classification_result | json }}"
      PLANS_JSON: "{{ outputs['get-available-plans'].plans_result | json }}"
      OCR_RESULT_JSON: "{{ outputs['process-invoice-ocr'].ocr_result | json }}"
    script: |
      import json
      import os
      lead_data = json.loads(os.getenv("LEAD_DATA_JSON", "{}"))
      ocr_data = json.loads(os.getenv("OCR_RESULT_JSON", "{}"))
      if ocr_data.get("is_qualified", False):
          print(f"üì± Lead qualificado! Persistindo dados para {lead_data.get('name')} no Supabase...")
          print("‚úÖ Dados persistidos com sucesso no Supabase")
          print('::{"outputs":{"lead_persisted":true}}::')
      else:
          print(f"‚ö†Ô∏è  Lead {lead_data.get('name')} n√£o qualificado - dados n√£o persistidos")
          print('::{"outputs":{"lead_persisted":false}}::')

errors:
  - id: qualification-error-handler
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena/kestra-python-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
    env:
      EXECUTION_JSON: "{{ execution | json }}"
    script: |
      import json
      import os
      from datetime import datetime

      # Carregar os dados da execu√ß√£o a partir da vari√°vel de ambiente
      execution_json = os.getenv("EXECUTION_JSON", "{}")
      execution = json.loads(execution_json)
      
      execution_id = execution.get("id")
      failed_task_info = None
      
      # Encontrar a primeira tarefa que falhou na lista de taskruns
      for task_run in execution.get("taskruns", []):
          if task_run.get("state", {}).get("current") == "FAILED":
              failed_task_info = task_run
              break
      
      failed_task_id = "unknown_task"
      error_message = "No specific error message found."
      
      if failed_task_info:
          failed_task_id = failed_task_info.get("taskId", "unknown_task")
          # Tenta extrair a mensagem de erro da √∫ltima tentativa da tarefa
          attempts = failed_task_info.get("attempts", [])
          if attempts:
              last_attempt = attempts[-1]
              # A mensagem de erro geralmente est√° nos logs da √∫ltima tentativa
              logs = last_attempt.get("logs", [])
              if logs:
                  # Pega a √∫ltima linha de log, que pode ser o erro
                  error_message = logs[-1].get("message", "Could not extract error from logs.")

      print(f"‚ùå ERRO NO WORKFLOW DE QUALIFICA√á√ÉO na tarefa: {failed_task_id}")
      print(f"üÜî Execution ID: {execution_id}")
      print(f"üìÑ Mensagem: {error_message}")
      print("‚è∞ Timestamp: " + datetime.now().isoformat())
      print("üìã Executando procedimento de fallback...")
      
      error_report = {
          "execution_id": execution_id,
          "failed_task": failed_task_id,
          "error_message": error_message,
          "error_timestamp": datetime.now().isoformat(),
          "workflow_stage": "unknown", # Poderia ser extra√≠do do failed_task_id
          "requires_manual_review": True
      }
      
      print("‚ö†Ô∏è  Workflow finalizado com erros - revis√£o manual necess√°ria")
      print(f'::{json.dumps({"outputs": {"error_report": error_report}})}::') 
