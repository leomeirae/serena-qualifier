id: full-lead-qualification-workflow
namespace: serena.energia
description: "Sistema completo de qualifica√ß√£o de leads com WhatsApp, IA e OCR"

labels:
  version: "1.0.0"
  environment: "production"
  system: "serena-qualifier"

inputs:
  - id: lead_name
    type: STRING
    required: true
  - id: lead_email
    type: STRING
    required: true
  - id: lead_phone
    type: STRING
    required: true
  - id: valor_conta_luz
    type: STRING
    required: false
  - id: tipo_cliente
    type: STRING
    required: false
  - id: cidade
    type: STRING
    required: false
  - id: invoice_image_path
    type: STRING
    required: false

triggers:
  - id: form-webhook
    type: io.kestra.plugin.core.trigger.Webhook
    key: "serena-capture-webhook"

tasks:
  # FASE 1: Inicializa√ß√£o e Estado da Conversa
  - id: initialize-qualification
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena/kestra-python-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
    env:
      LEAD_NAME: "{% if trigger is defined %}{{ trigger.body.lead_name }}{% else %}{{ inputs.lead_name }}{% endif %}"
      LEAD_EMAIL: "{% if trigger is defined %}{{ trigger.body.lead_email }}{% else %}{{ inputs.lead_email }}{% endif %}"
      LEAD_PHONE: "{% if trigger is defined %}{{ trigger.body.lead_phone }}{% else %}{{ inputs.lead_phone }}{% endif %}"
      VALOR_CONTA_LUZ: "{% if trigger is defined %}{{ trigger.body.valor_conta_luz }}{% else %}{{ inputs.valor_conta_luz }}{% endif %}"
      TIPO_CLIENTE: "{% if trigger is defined %}{{ trigger.body.tipo_cliente }}{% else %}{{ inputs.tipo_cliente }}{% endif %}"
      CIDADE: "{% if trigger is defined %}{{ trigger.body.cidade }}{% else %}{{ inputs.cidade }}{% endif %}"
      EXECUTION_ID: "{{ execution.id }}"
    script: |
      import os
      import json
      from datetime import datetime
      
      # Coleta dados do lead via vari√°veis de ambiente
      lead_data = {
          "name": os.getenv("LEAD_NAME"),
          "email": os.getenv("LEAD_EMAIL"),
          "phone": os.getenv("LEAD_PHONE"),
          "valor_conta_luz": os.getenv("VALOR_CONTA_LUZ"),
          "tipo_cliente": os.getenv("TIPO_CLIENTE"),
          "cidade": os.getenv("CIDADE"),
          "execution_id": os.getenv("EXECUTION_ID"),
          "timestamp": datetime.now().isoformat()
      }
      
      print(f"üöÄ Iniciando qualifica√ß√£o para: {lead_data['name']} ({lead_data['phone']})")
      print(f"üìß Email: {lead_data['email']}")
      print(f"üèôÔ∏è Cidade: {lead_data['cidade']}")
      print(f"‚ö° Valor conta: R${lead_data['valor_conta_luz']}")
      print(f"üè† Tipo cliente: {lead_data['tipo_cliente']}")

      # Output para pr√≥ximos tasks
      print('::' + json.dumps({"outputs": {"lead_data": lead_data}}) + '::')

  # FASE 2: Enviar Template WhatsApp REAL
  - id: send-welcome-whatsapp
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena/kestra-python-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
    env:
      LEAD_PHONE: "{{ outputs['initialize-qualification'].vars.lead_data.phone }}"
      LEAD_NAME: "{{ outputs['initialize-qualification'].vars.lead_data.name }}"
    script: |
      import os
      import json
      import requests

      phone = os.getenv("LEAD_PHONE")
      name = os.getenv("LEAD_NAME")

      print(f"üì± Enviando template WhatsApp REAL para {name} ({phone})")

      # ENVIO REAL via servi√ßo WhatsApp
      try:
          whatsapp_url = "http://whatsapp-service:8000/whatsapp/send_prosseguir"
          payload = {
              "phone": phone,
              "lead_name": name
          }
          
          response = requests.post(whatsapp_url, json=payload, timeout=30)
          response.raise_for_status()
          
          result = response.json()
          message_id = result.get("message_id", "")
          
          print(f"‚úÖ Template WhatsApp enviado com sucesso!")
          print(f"üì¨ Message ID: {message_id}")
          print(f"üì± Servi√ßo: whatsapp-service:8000")
          
          whatsapp_sent = True
          template_confirmed = "prosseguir_com_solicitacao"
          error_details = None
          
      except Exception as e:
          print(f"‚ùå Erro ao enviar WhatsApp: {str(e)}")
          whatsapp_sent = False
          template_confirmed = "none"
          error_details = str(e)

      print('::' + json.dumps({"outputs": {"whatsapp_sent": whatsapp_sent, "template_confirmed": template_confirmed, "error_details": error_details, "message_id": message_id if 'message_id' in locals() else None}}) + '::')

  # FASE 3: Classifica√ß√£o de Inten√ß√£o via IA
  - id: classify-lead-intent
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena/kestra-python-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
    env:
      LEAD_PHONE: "{{ outputs['initialize-qualification'].vars.lead_data.phone }}"
      CIDADE_LEAD: "{{ outputs['initialize-qualification'].vars.lead_data.cidade }}"
    script: |
      import os
      import json

      phone = os.getenv("LEAD_PHONE")
      cidade_form = os.getenv("CIDADE_LEAD")

      print(f"ü§ñ Classificando inten√ß√£o do lead {phone}")
      
      # Usar IA REAL para classificar dados do formul√°rio
      try:
          import sys
          sys.path.append('.')
          # Carregar .env primeiro
          from dotenv import load_dotenv
          load_dotenv('/app/.env')
          
          from scripts.ai_agent import process_ai_request
          
          # Preparar mensagem simulada baseada nos dados do formul√°rio
          form_message = f"Minha cidade √© {cidade_form}" if cidade_form else "N√£o informei cidade"
          
          # Classificar com IA real
          ai_result = process_ai_request(
              phone_number=phone,
              message=form_message,
              action="classify"
          )
          
          intent = ai_result.get("intention", "incompreensivel")
          confidence = ai_result.get("confidence", "low")
          
          # Extrair cidade se informada
          if intent == "informou_cidade" and cidade_form:
              extract_result = process_ai_request(
                  phone_number=phone,
                  message=form_message,
                  action="extract",
                  data_type="cidade"
              )
              extracted_city = extract_result.get("extracted_value", cidade_form)
      else:
              extracted_city = None
              intent = "precisa_informar_cidade"
              
          print(f"ü§ñ IA classificou inten√ß√£o: {intent}")
          print(f"üèôÔ∏è Cidade extra√≠da: {extracted_city or 'N/A'}")
          
      except Exception as e:
          print(f"‚ùå Erro na IA, usando fallback: {str(e)}")
          # Fallback para l√≥gica simples
          if cidade_form and len(cidade_form.strip()) > 0:
              intent = "informou_cidade"
              extracted_city = cidade_form.strip()
              confidence = "high"
          else:
              intent = "precisa_informar_cidade"
              extracted_city = None
              confidence = "medium"
      
      classification_result = {
          "intent": intent,
          "extracted_city": extracted_city,
          "confidence": confidence
      }
      
      print('::' + json.dumps({"outputs": {"classification_result": classification_result}}) + '::')

  # FASE 4: Consultar Planos da Serena
  - id: get-available-plans
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena/kestra-python-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
    env:
      CIDADE: "{% if trigger is defined %}{{ trigger.body.cidade }}{% else %}{{ inputs.cidade }}{% endif %}"
    script: |
      import json
      import requests
      import os
      
      # Cidade para consulta via vari√°vel de ambiente
      cidade = os.getenv("CIDADE") or "Recife"
      
      print("üîç Consultando planos para a cidade: " + cidade)
      
      # Consulta real √† API Serena
      try:
          from scripts.serena_api import get_plans_by_city, check_city_coverage
          
          print(f"üèôÔ∏è Consultando planos reais da Serena para: {cidade}")
          
          # Verificar cobertura da cidade
          has_coverage = check_city_coverage(cidade)
          print(f"üìç Cobertura para {cidade}: {has_coverage}")
          
          # Buscar planos dispon√≠veis
          plans = get_plans_by_city(cidade)
          
          if not plans:
              print(f"‚ö†Ô∏è Nenhum plano encontrado para {cidade}")
              plans_data = {
                  "success": False,
                  "cidade": cidade,
                  "plans": [],
                  "has_coverage": has_coverage,
                  "total_plans": 0,
                  "message": f"Nenhum plano dispon√≠vel para {cidade}"
              }
          else:
              print(f"‚úÖ {len(plans)} planos encontrados para {cidade}")
          plans_data = {
              "success": True,
              "cidade": cidade,
                  "plans": plans,
                  "has_coverage": has_coverage,
                  "total_plans": len(plans)
          }
          
      except Exception as e:
          print("‚ùå Erro ao consultar planos: " + str(e))
          plans_data = {
              "success": False,
              "cidade": cidade,
              "plans": [],
              "error": str(e),
              "total_plans": 0
          }
      
      print('::' + json.dumps({"outputs": {"plans_result": plans_data}}) + '::')

  # FASE 5: Consolidar Dados e Preparar Pr√≥ximo Passo
  - id: consolidate-lead-data
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena/kestra-python-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
    env:
      LEAD_DATA_JSON: "{{ outputs['initialize-qualification'].vars.lead_data | json }}"
      CLASSIFICATION_JSON: "{{ outputs['classify-lead-intent'].vars.classification_result | json }}"
      PLANS_JSON: "{{ outputs['get-available-plans'].vars.plans_result | json }}"
    script: |
      import json
      import os

      # Carregar dados de tasks anteriores
      lead_data = json.loads(os.getenv("LEAD_DATA_JSON", "{}"))
      classification = json.loads(os.getenv("CLASSIFICATION_JSON", "{}"))
      plans = json.loads(os.getenv("PLANS_JSON", "{}"))

      print(f"üìä Consolidando dados do lead: {lead_data.get('name')}")
      print(f"ü§ñ Inten√ß√£o classificada: {classification.get('intent')}")
      print(f"üèôÔ∏è Cidade identificada: {classification.get('extracted_city')}")
      print(f"üìã Planos encontrados: {plans.get('total_plans', 0)}")

      # Criar dados consolidados
      consolidated_data = {
          "lead_info": lead_data,
          "intent_classification": classification,
          "available_plans": plans,
          "next_step": "request_invoice" if classification.get('intent') == 'informou_cidade' else "need_more_info",
          "is_ready_for_qualification": plans.get('success', False) and classification.get('intent') == 'informou_cidade'
      }

      print(f"‚ú® Pr√≥ximo passo: {consolidated_data['next_step']}")
      print(f"‚úÖ Pronto para qualifica√ß√£o: {consolidated_data['is_ready_for_qualification']}")

      print('::' + json.dumps({"outputs": {"consolidated_data": consolidated_data}}) + '::')

  # FASE 6: Enviar Template "Prosseguir" (Solicitar Fatura)
  - id: send-proceed-template
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena/kestra-python-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
    env:
      CONSOLIDATED_DATA_JSON: "{{ outputs['consolidate-lead-data'].vars.consolidated_data | json }}"
    script: |
      import json
      import os

      consolidated = json.loads(os.getenv("CONSOLIDATED_DATA_JSON", "{}"))
      
      lead_name = consolidated.get('lead_info', {}).get('name', 'Cliente')
      is_ready = consolidated.get('is_ready_for_qualification', False)
      
      if is_ready:
          print(f"üì± Enviando template 'prosseguir' para {lead_name}")
          print("üìã Solicitando envio da conta de energia...")
          
          # Aqui seria o envio real do template WhatsApp solicitando a fatura
          template_sent = True
          template_name = "prosseguir_com_solicitacao"
          
          print("‚úÖ Template enviado com sucesso!")
      else:
          print(f"‚ö†Ô∏è Lead {lead_name} n√£o est√° pronto para qualifica√ß√£o")
          template_sent = False
          template_name = "none"
      
      print('::' + json.dumps({"outputs": {"template_sent": template_sent, "template_name": template_name}}) + '::')

  # FASE 7: Processar Fatura via OCR (Simulado - seria executado ap√≥s upload)
  - id: process-invoice-ocr
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena/kestra-python-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
    env:
      INVOICE_IMAGE_PATH: "{% if trigger is defined %}{{ trigger.body.invoice_image_path }}{% else %}{{ inputs.invoice_image_path }}{% endif %}"
      CONSOLIDATED_DATA_JSON: "{{ outputs['consolidate-lead-data'].vars.consolidated_data | json }}"
    script: |
      import os
      import json

      # Simular processamento OCR da fatura
      # Em produ√ß√£o, aqui seria o processamento real da imagem enviada pelo lead
      
      print("üìÑ Simulando processamento OCR da conta de energia...")
      
      # Dados simulados do OCR
      ocr_data = {
          "valor_total": "550.00",
          "mes_referencia": "Maio/2025", 
          "consumo_kwh": "400",
          "qualification_score": 85,
          "is_qualified": True
      }

      print(f"üí∞ Valor extra√≠do: R$ {ocr_data['valor_total']}")
      print(f"üìÖ M√™s refer√™ncia: {ocr_data['mes_referencia']}")
      print(f"‚ö° Consumo: {ocr_data['consumo_kwh']} kWh")
      print(f"üìä Score qualifica√ß√£o: {ocr_data['qualification_score']}")
      print(f"‚úÖ Qualificado: {ocr_data['is_qualified']}")

      print("üìÑ Processamento OCR simulado conclu√≠do.")
      print('::' + json.dumps({"outputs": {"ocr_result": ocr_data}}) + '::')

  # FASE 8: Relat√≥rio Final e Persist√™ncia
  - id: generate-final-report
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena/kestra-python-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
    env:
      LEAD_DATA_JSON: "{{ outputs['initialize-qualification'].vars.lead_data | json }}"
      OCR_RESULT_JSON: "{{ outputs['process-invoice-ocr'].vars.ocr_result | json }}"
      CONSOLIDATED_DATA_JSON: "{{ outputs['consolidate-lead-data'].vars.consolidated_data | json }}"
    script: |
      import json
      import os
      from datetime import datetime
      
      # Carregar todos os dados processados
      lead_data = json.loads(os.getenv("LEAD_DATA_JSON", "{}"))
      ocr_result = json.loads(os.getenv("OCR_RESULT_JSON", "{}"))
      consolidated = json.loads(os.getenv("CONSOLIDATED_DATA_JSON", "{}"))

      # Gerar relat√≥rio final
      final_report = {
          "execution_id": lead_data.get('execution_id'),
          "lead_name": lead_data.get('name'),
          "lead_email": lead_data.get('email'),
          "lead_phone": lead_data.get('phone'),
          "cidade": consolidated.get('intent_classification', {}).get('extracted_city'),
          "valor_conta_ocr": ocr_result.get('valor_total'),
          "qualification_score": ocr_result.get('qualification_score'),
          "is_qualified": ocr_result.get('is_qualified'),
          "plans_available": len(consolidated.get('available_plans', {}).get('plans', [])),
          "processing_timestamp": datetime.now().isoformat(),
          "status": "QUALIFIED" if ocr_result.get('is_qualified') else "NOT_QUALIFIED"
      }

      print("üìã RELAT√ìRIO FINAL DE QUALIFICA√á√ÉO")
      print("=" * 50)
      print(f"üë§ Lead: {final_report['lead_name']}")
      print(f"üìß Email: {final_report['lead_email']}")
      print(f"üì± Phone: {final_report['lead_phone']}")
      print(f"üèôÔ∏è Cidade: {final_report['cidade']}")
      print(f"üí∞ Valor Conta: R$ {final_report['valor_conta_ocr']}")
      print(f"üìä Score: {final_report['qualification_score']}")
      print(f"‚úÖ Status: {final_report['status']}")
      print(f"üìã Planos Dispon√≠veis: {final_report['plans_available']}")
      print("=" * 50)

      if final_report['is_qualified']:
          print("üéâ LEAD QUALIFICADO! Dados ser√£o persistidos no Supabase.")
      else:
          print("‚ö†Ô∏è  Lead n√£o qualificado - dados arquivados para an√°lise.")
      
      print('::' + json.dumps({"outputs": {"final_report": final_report}}) + '::')

errors:
  - id: qualification-error-handler
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena/kestra-python-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
    env:
      EXECUTION_JSON: "{{ execution | json }}"
    script: |
      import json
      import os
      from datetime import datetime

      # Carregar os dados da execu√ß√£o a partir da vari√°vel de ambiente
      execution_json = os.getenv("EXECUTION_JSON", "{}")
      execution = json.loads(execution_json)
      
      execution_id = execution.get("id")
      failed_task_info = None
      
      # Encontrar a primeira tarefa que falhou na lista de taskruns
      for task_run in execution.get("taskruns", []):
          if task_run.get("state", {}).get("current") == "FAILED":
              failed_task_info = task_run
              break
      
      failed_task_id = "unknown_task"
      error_message = "No specific error message found."
      
      if failed_task_info:
          failed_task_id = failed_task_info.get("taskId", "unknown_task")
          # Tenta extrair a mensagem de erro da √∫ltima tentativa da tarefa
          attempts = failed_task_info.get("attempts", [])
          if attempts:
              last_attempt = attempts[-1]
              # A mensagem de erro geralmente est√° nos logs da √∫ltima tentativa
              logs = last_attempt.get("logs", [])
              if logs:
                  # Pega a √∫ltima linha de log, que pode ser o erro
                  error_message = logs[-1].get("message", "Could not extract error from logs.")

      print(f"‚ùå ERRO NO WORKFLOW DE QUALIFICA√á√ÉO na tarefa: {failed_task_id}")
      print(f"üÜî Execution ID: {execution_id}")
      print(f"üìÑ Mensagem: {error_message}")
      print("‚è∞ Timestamp: " + datetime.now().isoformat())
      print("üìã Executando procedimento de fallback...")
      
      error_report = {
          "execution_id": execution_id,
          "failed_task": failed_task_id,
          "error_message": error_message,
          "error_timestamp": datetime.now().isoformat(),
          "workflow_stage": "unknown", # Poderia ser extra√≠do do failed_task_id
          "requires_manual_review": True
      }
      
      print("‚ö†Ô∏è  Workflow finalizado com erros - revis√£o manual necess√°ria")
      print('::' + json.dumps({"outputs": {"error_report": error_report}}) + '::') 