id: 2_ai_conversation_flow
namespace: serena.production
description: "Fluxo de Conversa com IA v9 - Agente com Consulta de Lead"

triggers:
  - id: webhook_lead_message
    type: io.kestra.plugin.core.trigger.Webhook
    key: converse_production_lead
    description: "Recebe mensagens do lead via WhatsApp Webhook"

variables:
  ai_model: "gpt-4o-mini"
  max_tokens: 1500
  temperature: 0.7

tasks:
  - id: run-silvia-agent
    type: io.kestra.plugin.scripts.python.Script
    description: "Executa o Agente de IA 'S√≠lvia' para processar a mensagem do lead."
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: ${KESTRA_AGENT_IMAGE}

    env:
      OPENAI_API_KEY: "{{ secret('OPENAI_API_KEY') }}"
      DB_CONNECTION_STRING: "{{ secret('DB_CONNECTION_STRING') }}"
      SERENA_API_TOKEN: "{{ secret('SERENA_API_TOKEN') }}"
      SERENA_API_BASE_URL: "https://partnership-service-staging.api.srna.co"
      
    inputFiles:
      # Scripts do Agente embutidos diretamente no workflow
      scripts/agent_orchestrator.py: |
        import os
        import argparse
        import json
        from dotenv import load_dotenv

        # --- Importa√ß√µes Essenciais do LangChain ---
        from langchain_openai import ChatOpenAI
        from langchain.agents import AgentExecutor, create_openai_tools_agent
        from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
        from langchain_community.chat_message_histories import ChatMessageHistory
        from langchain_core.runnables.history import RunnableWithMessageHistory

        # --- Importar Ferramentas Espec√≠ficas do Agente ---
        from scripts.agent_tools.knowledge_base_tool import consultar_faq_serena
        from scripts.agent_tools.serena_tools import (
            buscar_planos_de_energia_por_localizacao,
            analisar_conta_de_energia_de_imagem,
        )
        from scripts.agent_tools.supabase_agent_tools import salvar_ou_atualizar_lead_silvia, consultar_dados_lead

        # Carregar vari√°veis de ambiente (ex: OPENAI_API_KEY)
        load_dotenv()

        # --- PASSO 1: Montagem do Agente "S√≠lvia" ---

        # 1.1 - Lista de ferramentas que o agente poder√° usar.
        tools = [
            consultar_dados_lead,
            consultar_faq_serena,
            buscar_planos_de_energia_por_localizacao,
            analisar_conta_de_energia_de_imagem,
            salvar_ou_atualizar_lead_silvia
        ]

        # 1.2 - O "c√©rebro" do agente: o modelo de linguagem.
        llm = ChatOpenAI(model="gpt-4o-mini", temperature=0.7)

        # 1.3 - O prompt do agente, definindo a persona e as entradas.
        # O conte√∫do do FAQ_INTERNO_TRAINING.md √© inserido aqui.
        system_prompt = """
        # QUEM SOU EU
        - **Identidade**: Meu nome √© S√≠lvia, sou uma representante virtual especialista da Serena Energia.
        - **Miss√£o**: Minha miss√£o √© ajudar os clientes a entenderem e contratarem planos de energia limpa de forma 100% digital, tornando o processo f√°cil, r√°pido e sem complica√ß√µes.
        - **Comportamento**: Meu tom de voz √© informal, simp√°tico e bem-humorado. Sou prestativa e guio os clientes pelo processo de qualifica√ß√£o, usando emojis com modera√ß√£o para criar uma conex√£o humana. Ajo como uma especialista que descomplica.
        - **Objetivo Principal**: Qualificar leads (consumo > 200kWh) e gui√°-los para enviar a conta de energia.

        # COMO DEVO AGIR
        1.  **PRIMEIRA A√á√ÉO OBRIGAT√ìRIA**: No in√≠cio de TODA conversa, use a ferramenta 'consultar_dados_lead' com o n√∫mero de telefone do usu√°rio para carregar seu contexto. Isso √© crucial para saber com quem voc√™ est√° falando.
        2.  Ap√≥s carregar o contexto, apresente-se como "S√≠lvia da Serena Energia".
        3.  Para d√∫vidas comuns dos clientes, use a ferramenta 'consultar_faq_serena'.
        4.  Se o usu√°rio perguntar sobre planos, descontos ou cobertura, use a ferramenta 'buscar_planos_de_energia_por_localizacao'.
        5.  Ap√≥s tirar as d√∫vidas, seu principal objetivo √© incentivar o usu√°rio a enviar uma foto da conta de energia para uma an√°lise de desconto.
        6.  Quando uma imagem for enviada, use a ferramenta 'analisar_conta_de_energia_de_imagem'.
        7.  Com os dados da conta em m√£os, confirme as informa√ß√µes com o usu√°rio e, se estiverem corretas, use 'salvar_ou_atualizar_lead_silvia' para registrar o lead.
        """

        prompt = ChatPromptTemplate.from_messages([
            ("system", system_prompt),
            MessagesPlaceholder(variable_name="chat_history"),
            ("user", "{input}"),
            MessagesPlaceholder(variable_name="agent_scratchpad"),
        ])

        # 1.4 - Cria o agente, unindo o LLM, o prompt e as ferramentas.
        agent = create_openai_tools_agent(llm, tools, prompt)

        # 1.5 - Cria o executor do agente.
        agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)


        # --- PASSO 2: Adicionar Mem√≥ria de Conversa ---

        # 2.1 - Dicion√°rio para armazenar o hist√≥rico de cada sess√£o de chat.
        # Em um ambiente de produ√ß√£o, isso seria substitu√≠do por um banco de dados como Redis.
        store = {}

        def get_session_history(session_id: str) -> ChatMessageHistory:
            """Busca ou cria um hist√≥rico de chat para uma sess√£o espec√≠fica."""
            if session_id not in store:
                store[session_id] = ChatMessageHistory()
            return store[session_id]

        # 2.2 - Envolve o executor do agente com o gerenciador de hist√≥rico.
        # Esta √© a cadeia final, pronta para ser usada.
        agent_with_chat_history = RunnableWithMessageHistory(
            agent_executor,
            get_session_history,
            input_messages_key="input",
            history_messages_key="chat_history",
        )

        # --- PASSO 3: Fun√ß√£o Principal de Execu√ß√£o ---

        def handle_agent_invocation(phone_number: str, user_message: str, image_url: str = None):
            """
            Recebe a mensagem do usu√°rio, prepara a entrada e invoca o agente com mem√≥ria.
            """
            if image_url:
                input_data = f"O usu√°rio enviou esta imagem para an√°lise: {image_url}. Mensagem adicional: {user_message}"
            else:
                input_data = user_message

            # A configura√ß√£o da sess√£o √© passada via 'configurable'.
            config = {"configurable": {"session_id": phone_number}}

            response = agent_with_chat_history.invoke(
                {"input": input_data},
                config=config
            )
            
            return {"response": response.get("output", "N√£o consegui processar sua solicita√ß√£o.")}

        # --- PASSO 4: Ponto de Entrada para o Script (para testes) ---

        if __name__ == '__main__':
            parser = argparse.ArgumentParser(description='Orquestrador do Agente S√≠lvia.')
            parser.add_argument('--phone_number', type=str, required=True, help='N√∫mero de telefone do usu√°rio (ID da sess√£o).')
            parser.add_argument('--message', type=str, required=True, help='Mensagem do usu√°rio.')
            parser.add_argument('--image_url', type=str, help='URL da imagem (opcional).')
            
            args = parser.parse_args()

            # Executa a l√≥gica do agente
            result = handle_agent_invocation(args.phone_number, args.message, args.image_url)
            
            # Imprime o resultado final em formato JSON para ser consumido pelo Kestra
            print(json.dumps(result))
      
      scripts/agent_tools/knowledge_base_tool.py: |
        from langchain_core.documents import Document
        from langchain_openai import OpenAIEmbeddings
        from langchain_community.vectorstores import FAISS
        from langchain_core.tools import tool

        # Importa a lista de FAQ do nosso novo arquivo de dados
        from scripts.agent_tools.faq_data import FAQ_LIST

        def get_faq_retriever():
            """
            Cria um retriever FAISS a partir de uma lista de FAQs pr√©-definida.
            """
            # Converte a lista de FAQ em documentos LangChain para indexa√ß√£o
            documents = [
                Document(page_content=f"Pergunta: {item['pergunta']}\nResposta: {item['resposta']}")
                for item in FAQ_LIST
            ]
            
            if not documents:
                raise ValueError("A lista de FAQ est√° vazia. N√£o √© poss√≠vel criar a base de conhecimento.")

            embeddings = OpenAIEmbeddings(model="text-embedding-3-small")
            
            # Cria o √≠ndice vetorial em mem√≥ria
            vector_store = FAISS.from_documents(documents, embeddings)
            
            return vector_store.as_retriever(search_kwargs={"k": 3}) # Retorna os 3 resultados mais relevantes

        # O retriever √© criado uma vez quando o m√≥dulo √© importado para otimizar a performance
        faq_retriever = get_faq_retriever()

        @tool
        def consultar_faq_serena(pergunta_do_usuario: str) -> str:
            """
            Use esta ferramenta para responder a perguntas comuns dos clientes sobre a Serena Energia, 
            como funciona o servi√ßo, custos, instala√ß√£o e cobertura. A entrada deve ser a 
            pergunta do usu√°rio.
            """
            docs = faq_retriever.invoke(pergunta_do_usuario)
            
            if not docs:
                return "N√£o encontrei uma resposta para isso em nosso FAQ. Voc√™ poderia tentar reformular a pergunta?"
                
            # Concatena o conte√∫do dos documentos encontrados para formar o contexto
            contexto = "\n\n".join([doc.page_content for doc in docs])
            
            return contexto
      
      scripts/agent_tools/faq_data.py: |
        # -*- coding: utf-8 -*-
        """
        Fonte de dados para a ferramenta de conhecimento do Agente S√≠lvia.
        Este arquivo cont√©m as perguntas e respostas mais comuns dos leads.
        """

        FAQ_LIST = [
            {
                "pergunta": "O que √© energia limpa? √â algum tipo de pegadinha?",
                "resposta": "√ìtima pergunta! N√£o √© pegadinha, n√£o! Energia limpa √© aquela que geramos a partir de fontes renov√°veis, como a solar e a e√≥lica, que n√£o poluem o meio ambiente. √â uma possibilidade que virou lei h√° alguns anos, e nosso papel na Serena √© tornar isso f√°cil e seguro para voc√™!"
            },
            {
                "pergunta": "Vou precisar instalar placas solares na minha casa ou ter algum custo com obra?",
                "resposta": "N√£o, de jeito nenhum! E essa √© a melhor parte. N√≥s produzimos a energia em nossos parques solares de alta tecnologia, e a distribuidora da sua cidade entrega essa energia na sua casa. Voc√™ n√£o tem nenhum custo com instala√ß√£o, obras ou manuten√ß√£o."
            },
            {
                "pergunta": "Quanto eu vou economizar de verdade na minha conta de luz?",
                "resposta": "Sua economia pode chegar a at√© 21% de desconto j√° no primeiro ano se voc√™ for um cliente residencial ou de baixa tens√£o. Para empresas maiores, no Mercado Livre de Energia, a economia pode chegar a at√© 40%!"
            },
            {
                "pergunta": "Como vai ficar minha conta de luz depois que eu contratar a Serena?",
                "resposta": "Fica mais simples! Voc√™ passar√° a receber uma fatura √∫nica, j√° com o desconto da energia limpa aplicado. Essa fatura incluir√° os custos da distribuidora (como taxa m√≠nima e ilumina√ß√£o p√∫blica) e o seu consumo de energia com a Serena. Pode desconsiderar o boleto antigo da sua distribuidora."
            },
            {
                "pergunta": "Se acabar a energia na minha rua, para quem eu ligo?",
                "resposta": "Voc√™ continua falando com a sua distribuidora de energia local (como a CELPE, ENEL, etc.). Eles ainda s√£o os respons√°veis por toda a infraestrutura dos fios e postes que levam a energia at√© voc√™. A Serena garante a energia mais barata, e a distribuidora garante a entrega."
            },
            {
                "pergunta": "Voc√™s atendem na minha cidade?",
                "resposta": "Estamos em todo o Brasil! Para clientes de m√©dia e alta tens√£o, a cobertura √© nacional. Para clientes de baixa tens√£o, como resid√™ncias, atendemos mais de 2 mil munic√≠pios e estamos crescendo muito r√°pido. Para eu te dar a resposta exata, s√≥ preciso saber sua cidade e estado!"
            }
        ]
      
      scripts/agent_tools/serena_tools.py: |
        from langchain_core.tools import tool
        import json
        import os
        import base64
        from openai import OpenAI
        from scripts.serena_api import SerenaAPI

        # --- Inst√¢ncias de Clientes ---
        serena_api_client = SerenaAPI()
        # Inicializa o cliente OpenAI para a ferramenta de vis√£o
        openai_client = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))

        # --- Fun√ß√µes Auxiliares ---

        def _analyze_bill_with_vision(image_url: str) -> dict:
            """
            Fun√ß√£o extra√≠da e adaptada de ai_conversation_handler.py para usar o modelo de vis√£o.
            """
            response = openai_client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": "Analise a imagem desta conta de energia e extraia o nome do titular, o valor total e o consumo em kWh. Retorne apenas um JSON com as chaves 'nome_cliente', 'valor_total' e 'consumo_kwh'."},
                            {"type": "image_url", "image_url": {"url": image_url}},
                        ],
                    }
                ],
                max_tokens=300,
            )
            # Supondo que a resposta seja um JSON bem formatado
            try:
                content = response.choices[0].message.content
                if content:
                    return json.loads(content)
                return {}
            except (json.JSONDecodeError, IndexError):
                return {}


        # --- Ferramentas para o Agente ---

        @tool
        def buscar_planos_de_energia_por_localizacao(localizacao: str) -> str:
            """
            Use esta ferramenta quando um usu√°rio perguntar sobre planos, descontos ou 
            cobertura em uma cidade espec√≠fica. A entrada deve ser a localiza√ß√£o no 
            formato 'cidade, estado'. Retorna os planos dispon√≠veis ou uma mensagem 
            de que a √°rea n√£o √© atendida.
            """
            try:
                cidade, estado = localizacao.split(',')
                cidade = cidade.strip()
                estado = estado.strip()
                
                planos = serena_api_client.get_plans(cidade, estado)
                
                if planos:
                    return json.dumps(planos)
                else:
                    return f"A Serena Energia ainda n√£o atende a regi√£o de {cidade}, {estado}."
            except ValueError:
                return "Formato de localiza√ß√£o inv√°lido. Por favor, use 'cidade, estado'."
            except Exception as e:
                return f"Ocorreu um erro ao buscar os planos: {e}"

        @tool
        def analisar_conta_de_energia_de_imagem(image_url: str) -> str:
            """
            Use esta ferramenta APENAS quando o usu√°rio enviar uma imagem de uma 
            conta de luz. Ela recebe a URL da imagem, extrai dados como valor, 
            consumo e nome do cliente, e retorna essas informa√ß√µes estruturadas em JSON.
            """
            try:
                dados_extraidos = _analyze_bill_with_vision(image_url)
                
                if dados_extraidos and all(k in dados_extraidos for k in ['nome_cliente', 'valor_total', 'consumo_kwh']):
                    return json.dumps(dados_extraidos)
                else:
                    return "N√£o foi poss√≠vel extrair todos os dados necess√°rios da imagem. Pe√ßa ao usu√°rio para enviar uma imagem mais n√≠tida."
                    
            except Exception as e:
                return f"Ocorreu um erro ao processar a imagem da conta de energia: {e}"
      
      scripts/agent_tools/supabase_agent_tools.py: |
        import os
        import psycopg2
        import json
        import re
        from dotenv import load_dotenv
        from langchain_core.tools import tool

        # Carrega vari√°veis de ambiente
        load_dotenv()

        @tool
def consultar_dados_lead(phone_number: str) -> str:
    """
    Consulta os dados de um lead existente no banco de dados usando o n√∫mero de telefone.
    Use esta ferramenta no in√≠cio de cada conversa para carregar o contexto do lead, 
    como nome e cidade, antes de interagir com ele.
    """
    conn_string = os.getenv("DB_CONNECTION_STRING")
    if not conn_string:
        # Tenta com o prefixo SECRET_ se a vari√°vel normal n√£o existir
        conn_string = os.getenv("SECRET_DB_CONNECTION_STRING")
        if not conn_string:
            return "Erro: A vari√°vel de ambiente DB_CONNECTION_STRING ou SECRET_DB_CONNECTION_STRING n√£o foi encontrada."

    try:
        # Normaliza o n√∫mero de telefone para busca
        digits_only = re.sub(r'\D', '', phone_number)
        
        # Cria uma lista de poss√≠veis formatos de telefone para busca
        possible_formats = []
        
        # Se come√ßar com c√≥digo do pa√≠s (55)
        if digits_only.startswith('55'):
            without_country = digits_only[2:]  # Remove o 55
            possible_formats.append(without_country)  # Formato sem o 55
            
            # Se tiver o 9 ap√≥s o DDD (formato novo)
            if len(without_country) >= 9 and without_country[2] == '9':
                possible_formats.append(without_country[:2] + without_country[3:])  # Remove o 9
            
            # Se n√£o tiver o 9 (formato antigo)
            if len(without_country) == 8:
                possible_formats.append(without_country[:2] + '9' + without_country[2:])  # Adiciona o 9
        else:
            possible_formats.append(digits_only)
        
        # Adicione outros formatos poss√≠veis para cobrir mais casos
        if len(digits_only) == 11:  # formato 5581987654321 ou 81987654321
            possible_formats.append(digits_only[-10:])  # Apenas DDD + n√∫mero sem o 9
            possible_formats.append(digits_only[-8:])   # Apenas o n√∫mero base sem DDD e sem 9
        
        # Adiciona o formato exato e remove duplicatas
        possible_formats.append(digits_only)
        possible_formats = list(set(possible_formats))
        
        print(f"DEBUG: Tentando formatos de telefone: {possible_formats}")
        
        with psycopg2.connect(conn_string) as conn:
            with conn.cursor() as cur:
                for format_to_try in possible_formats:
                    cur.execute(
                        "SELECT name, city, state, invoice_amount, client_type FROM leads WHERE phone_number = %s",
                        (format_to_try,)
                    )
                    result = cur.fetchone()
                    if result:
                        lead_data = {
                            "name": result[0],
                            "city": result[1],
                            "state": result[2],
                            "invoice_amount": result[3],
                            "client_type": result[4],
                            "phone_format": format_to_try  # Para debug
                        }
                        return json.dumps(lead_data)
                
                # Tenta uma √∫ltima busca com LIKE para os √∫ltimos 8 d√≠gitos
                if len(digits_only) >= 8:
                    last_8_digits = digits_only[-8:]
                    print(f"DEBUG: Tentando busca por LIKE com √∫ltimos 8 d√≠gitos: {last_8_digits}")
                    cur.execute(
                        "SELECT name, city, state, invoice_amount, client_type, phone_number FROM leads WHERE phone_number LIKE %s",
                        (f"%{last_8_digits}",)
                    )
                    result = cur.fetchone()
                    if result:
                        lead_data = {
                            "name": result[0],
                            "city": result[1],
                            "state": result[2],
                            "invoice_amount": result[3],
                            "client_type": result[4],
                            "phone_number": result[5]  # O n√∫mero encontrado no banco
                        }
                        return json.dumps(lead_data)
                
                return "Nenhum dado encontrado para este n√∫mero de telefone."

    except psycopg2.Error as e:
        return f"Erro ao consultar o banco de dados: {e}"
    except Exception as e:
        return f"Ocorreu um erro inesperado: {e}"

        @tool
        def salvar_ou_atualizar_lead_silvia(dados_lead: str) -> str:
            """
            Salva ou atualiza os dados de um lead no banco de dados. 
            A entrada deve ser um dicion√°rio em formato de string JSON contendo as chaves: 
            'name', 'phone', 'email', 'city', 'state', e um dicion√°rio aninhado 
            'energy_bill_data' com 'valor_total' e 'client_type'.
            Use esta ferramenta ap√≥s confirmar os dados com o usu√°rio.
            """
            conn_string = os.getenv("DB_CONNECTION_STRING")
            
            if not conn_string:
                # Tenta com o prefixo SECRET_ se a vari√°vel normal n√£o existir
                conn_string = os.getenv("SECRET_DB_CONNECTION_STRING")
                if not conn_string:
                    return "Erro: A vari√°vel de ambiente DB_CONNECTION_STRING ou SECRET_DB_CONNECTION_STRING n√£o foi encontrada."

            try:
                dados_dict = json.loads(dados_lead)
                energy_data = dados_dict.get('energy_bill_data', {})

                phone = dados_dict.get('phone')
                name = dados_dict.get('name')
                email = dados_dict.get('email', '')
                account_value = energy_data.get('valor_total')
                client_type = energy_data.get('client_type', 'Residencial')
                city = dados_dict.get('city')
                state = dados_dict.get('state')

                with psycopg2.connect(conn_string) as conn:
                    with conn.cursor() as cur:
                        additional_data_payload = {"email": email, "source": "silvia_agent"}
                        additional_data_json = json.dumps(additional_data_payload)

                        cur.execute(
                            """
                            INSERT INTO leads (phone_number, name, invoice_amount, client_type, state, city, additional_data, updated_at)
                            VALUES (%s, %s, %s, %s, %s, %s, %s, CURRENT_TIMESTAMP)
                            ON CONFLICT (phone_number) 
                            DO UPDATE SET
                                name = EXCLUDED.name,
                                invoice_amount = EXCLUDED.invoice_amount,
                                client_type = EXCLUDED.client_type,
                                state = EXCLUDED.state,
                                city = EXCLUDED.city,
                                additional_data = leads.additional_data || %s::jsonb,
                                updated_at = CURRENT_TIMESTAMP;
                            """,
                            (phone, name, account_value, client_type, state, city, additional_data_json, additional_data_json)
                        )
                return "Dados do lead salvos com sucesso no sistema."

            except json.JSONDecodeError:
                return "Erro: A entrada para a ferramenta n√£o √© um JSON v√°lido."
            except psycopg2.Error as e:
                return f"Erro ao interagir com o banco de dados: {e}"
            except Exception as e:
                return f"Ocorreu um erro inesperado: {e}"
      
      scripts/serena_api.py: |
        """
        Cliente API para integra√ß√£o com servi√ßos da Serena Energia.
        """
        import os
        import requests
        import logging
        from typing import Dict, List, Any, Optional

        # Configurar logging
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)

        class SerenaAPI:
            """
            Cliente para a API da Serena Energia.
            Fornece m√©todos para interagir com servi√ßos como consulta de planos,
            cria√ß√£o de leads, etc.
            """
            
            def __init__(self, api_token=None, base_url=None):
                """
                Inicializa o cliente da API.
                
                Args:
                    api_token (str, optional): Token de autentica√ß√£o para a API.
                                              Se None, tentar√° carregar da vari√°vel de ambiente.
                    base_url (str, optional): URL base para as requisi√ß√µes.
                                             Se None, tentar√° carregar da vari√°vel de ambiente.
                """
                self.api_token = api_token or os.getenv("SERENA_API_TOKEN")
                self.base_url = base_url or os.getenv("SERENA_API_BASE_URL", "https://partnership-service-staging.api.srna.co")
                
                if not self.api_token:
                    logger.warning("API Token n√£o fornecido. Algumas opera√ß√µes podem falhar.")
                
                logger.info(f"Inicializando cliente SerenaAPI com base_url: {self.base_url}")
            
            def get_headers(self) -> Dict[str, str]:
                """
                Retorna os headers para as requisi√ß√µes √† API.
                
                Returns:
                    Dict[str, str]: Headers para autentica√ß√£o e formato de conte√∫do.
                """
                return {
                    "Authorization": f"Bearer {self.api_token}",
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            
            def handle_response(self, response: requests.Response) -> Dict[str, Any]:
                """
                Processa a resposta da API, tratando poss√≠veis erros.
                
                Args:
                    response (requests.Response): Resposta da requisi√ß√£o.
                    
                Returns:
                    Dict[str, Any]: Dados da resposta.
                    
                Raises:
                    Exception: Se a resposta contiver um c√≥digo de erro.
                """
                try:
                    # Tentar decodificar a resposta como JSON
                    data = response.json()
                    
                    # Verificar se a resposta indica erro
                    if response.status_code >= 400:
                        error_message = data.get('message', 'Erro desconhecido na API')
                        logger.error(f"API Error [{response.status_code}]: {error_message}")
                        raise Exception(f"API Error: {error_message}")
                    
                    return data
                    
                except ValueError:
                    # Se a resposta n√£o for um JSON v√°lido
                    logger.error(f"Resposta inv√°lida da API: {response.text}")
                    if response.status_code >= 400:
                        raise Exception(f"API Error [{response.status_code}]: {response.text}")
                    return {"message": response.text}
            
            def get_plans(self, cidade: str, estado: str) -> List[Dict[str, Any]]:
                """
                Busca planos dispon√≠veis para uma determinada localiza√ß√£o.
                
                Args:
                    cidade (str): Nome da cidade.
                    estado (str): Sigla do estado (ex: SP, RJ).
                    
                Returns:
                    List[Dict[str, Any]]: Lista de planos dispon√≠veis.
                """
                logger.info(f"[get_plans] Buscando planos para {cidade}, {estado}")
                
                url = f"{self.base_url}/plans"
                params = {
                    "city": cidade,
                    "state": estado
                }
                
                try:
                    response = requests.get(url, headers=self.get_headers(), params=params)
                    data = self.handle_response(response)
                    
                    # Extrair apenas os dados relevantes dos planos
                    plans = data.get('plans', [])
                    simplified_plans = []
                    
                    for plan in plans:
                        simplified_plan = {
                            "id": plan.get('id'),
                            "nome": plan.get('name'),
                            "desconto": plan.get('discount', 0),
                            "tipo": plan.get('type'),
                            "prazo_contrato": plan.get('contract_period'),
                            "valor_minimo": plan.get('min_value', 0)
                        }
                        simplified_plans.append(simplified_plan)
                    
                    logger.info(f"[get_plans] Encontrados {len(simplified_plans)} planos")
                    return simplified_plans
                    
                except Exception as e:
                    logger.error(f"[get_plans] Erro ao buscar planos: {e}")
                    return []

            def create_lead(self, lead_data: Dict[str, Any]) -> Dict[str, Any]:
                """
                Cria um novo lead na Serena Energia.
                
                Args:
                    lead_data (Dict[str, Any]): Dados do lead a ser criado.
                    
                Returns:
                    Dict[str, Any]: Dados do lead criado ou mensagem de erro.
                """
                logger.info("[create_lead] Criando novo lead")
                
                url = f"{self.base_url}/leads"
                
                # Validar dados m√≠nimos
                required_fields = ['name', 'phone', 'city', 'state']
                for field in required_fields:
                    if field not in lead_data:
                        logger.error(f"[create_lead] Campo obrigat√≥rio ausente: {field}")
                        return {"error": f"Campo obrigat√≥rio ausente: {field}"}
                
                try:
                    response = requests.post(url, headers=self.get_headers(), json=lead_data)
                    result = self.handle_response(response)
                    logger.info(f"[create_lead] Lead criado com sucesso: {result.get('id')}")
                    return result
                    
                except Exception as e:
                    logger.error(f"[create_lead] Erro ao criar lead: {e}")
                    return {"error": str(e)}

            def get_lead(self, lead_id: str) -> Optional[Dict[str, Any]]:
                """
                Busca informa√ß√µes de um lead espec√≠fico.
                
                Args:
                    lead_id (str): ID do lead a ser consultado.
                    
                Returns:
                    Optional[Dict[str, Any]]: Dados do lead ou None se n√£o encontrado.
                """
                logger.info(f"[get_lead] Buscando lead: {lead_id}")
                
                url = f"{self.base_url}/leads/{lead_id}"
                
                try:
                    response = requests.get(url, headers=self.get_headers())
                    
                    # Se o lead n√£o existe, retorna None
                    if response.status_code == 404:
                        logger.info(f"[get_lead] Lead n√£o encontrado: {lead_id}")
                        return None
                        
                    result = self.handle_response(response)
                    logger.info(f"[get_lead] Lead recuperado com sucesso")
                    return result
                    
                except Exception as e:
                    logger.error(f"[get_lead] Erro ao buscar lead: {e}")
                    return None

            def update_lead(self, lead_id: str, update_data: Dict[str, Any]) -> Dict[str, Any]:
                """
                Atualiza informa√ß√µes de um lead existente.
                
                Args:
                    lead_id (str): ID do lead a ser atualizado.
                    update_data (Dict[str, Any]): Novos dados para o lead.
                    
                Returns:
                    Dict[str, Any]: Dados do lead atualizado ou mensagem de erro.
                """
                logger.info(f"[update_lead] Atualizando lead: {lead_id}")
                
                url = f"{self.base_url}/leads/{lead_id}"
                
                try:
                    response = requests.patch(url, headers=self.get_headers(), json=update_data)
                    result = self.handle_response(response)
                    logger.info(f"[update_lead] Lead atualizado com sucesso")
                    return result
                    
                except Exception as e:
                    logger.error(f"[update_lead] Erro ao atualizar lead: {e}")
                    return {"error": str(e)}
            
            def search_leads_by_phone(self, phone_number: str) -> List[Dict[str, Any]]:
                """
                Busca leads pelo n√∫mero de telefone.
                
                Args:
                    phone_number (str): N√∫mero de telefone para buscar.
                    
                Returns:
                    List[Dict[str, Any]]: Lista de leads encontrados.
                """
                logger.info(f"[search_leads_by_phone] Buscando leads com telefone: {phone_number}")
                
                url = f"{self.base_url}/leads/search"
                params = {"phone": phone_number}
                
                try:
                    response = requests.get(url, headers=self.get_headers(), params=params)
                    data = self.handle_response(response)
                    leads = data.get('leads', [])
                    logger.info(f"[search_leads_by_phone] Encontrados {len(leads)} leads")
                    return leads
                    
                except Exception as e:
                    logger.error(f"[search_leads_by_phone] Erro ao buscar leads: {e}")
                    return []
      
      # __init__.py para os diret√≥rios
      scripts/__init__.py: ""
      scripts/agent_tools/__init__.py: ""
      
      # Arquivo de depend√™ncias
      requirements.txt: |
        fastapi==0.110.1
        uvicorn[standard]==0.23.1
        requests==2.31.0
        supabase==2.0.2
        openai>=1.40.0
        anthropic==0.25.0
        google-generativeai==0.7.0
        pydantic==2.3.0
        pytesseract==0.3.10
        pdf2image==1.16.3
        opencv-python==4.8.1.78
        python-dotenv==1.0.1
        psycopg2-binary==2.9.9
        httpx==0.24.1
        tenacity==8.2.2

        # LangChain Core (vers√µes flex√≠veis - deixar pip resolver)
        langchain>=0.2.0
        langchain-openai>=0.1.0
        langchain-community>=0.2.0

        # RAG dependencies (NOVO)
        faiss-cpu==1.8.0
        tiktoken==0.7.0
        python-json-logger==2.0.7
        kestra==0.18.0
        urllib3==2.2.1
        chardet==5.2.0
        certifi==2024.7.4

    # Depend√™ncias j√° est√£o instaladas na imagem kestra-agent
    beforeCommands: []

    script: |
      from scripts.agent_orchestrator import handle_agent_invocation
      phone_number = "{{ trigger.body.phone }}"
      user_message = "{{ trigger.body.message }}"
      # O n√∫mero de telefone tamb√©m √© o input inicial para o agente carregar o contexto
      initial_input = phone_number
      
      result = handle_agent_invocation(phone_number, user_message, initial_input)
      
      from kestra import Kestra
      Kestra.outputs({'response': result['response']})

  - id: log-whatsapp-debug
    type: io.kestra.plugin.core.log.Log
    runIf: "{{ outputs['run-silvia-agent'].exitCode == 0 }}"
    message: |
      üîç Debug WhatsApp - Preparando envio:
      Telefone: {{ trigger.body.phone }}
      Response exists: {{ outputs['run-silvia-agent'].vars.response != null }}
      Response not empty: {{ outputs['run-silvia-agent'].vars.response != '' }}
      Response length: {{ outputs['run-silvia-agent'].vars.response | length }}

  - id: send-whatsapp-reply
    type: io.kestra.plugin.core.http.Request
    uri: "https://graph.facebook.com/v20.0/599096403294262/messages"
    method: POST
    headers:
      Authorization: "Bearer {{ secret('WHATSAPP_API_TOKEN') }}"
      Content-Type: "application/json"
    body: |
      {
        "messaging_product": "whatsapp",
        "to": "{{ trigger.body.phone }}",
        "type": "text",
        "text": { "body": "{{ outputs['run-silvia-agent'].vars.response }}" }
      }
    runIf: "{{ outputs['run-silvia-agent'].exitCode == 0 and outputs['run-silvia-agent'].vars.response != null and outputs['run-silvia-agent'].vars.response != '' }}"

  - id: log-processo-ok
    type: io.kestra.plugin.core.log.Log
    runIf: "{{ outputs['run-silvia-agent'].exitCode == 0 }}"
    message: |
      ‚úÖ Lead respondido com sucesso via Agente S√≠lvia.
      Telefone: {{ trigger.body.phone }}
      Resposta: {{ outputs['run-silvia-agent'].vars.response }}

  - id: log-processo-erro
    type: io.kestra.plugin.core.log.Log
    level: ERROR
    runIf: "{{ outputs['run-silvia-agent'].exitCode != 0 }}"
    message: |
      ‚ùå Erro no processamento do Agente S√≠lvia.
      Telefone: {{ trigger.body.phone }}
      Erro: {{ outputs['run-silvia-agent'].stderr }}
      Verifique os logs detalhados da tarefa 'run-silvia-agent'.