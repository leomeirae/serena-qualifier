id: native-openai-flow
namespace: serena.energia
description: "Conversação com IA usando plugin nativo OpenAI do Kestra - Arquitetura Simplificada"

triggers:
  - id: conversation-webhook
    type: io.kestra.plugin.core.trigger.Webhook
    key: ai_conversation_webhook
    description: "Webhook para receber mensagens de leads - Versão Nativa"

inputs:
  - id: phone
    type: STRING
    required: true
    description: "Número de telefone do lead (+5581999887766)"
  - id: message
    type: STRING
    required: true
    description: "Mensagem enviada pelo lead"
  - id: lead_name
    type: STRING
    required: false
    description: "Nome do lead (opcional)"

tasks:
  # Task 1: Recuperar histórico de conversa do Supabase
  - id: get-conversation-history
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "python:3.11-slim"
    beforeCommands:
      - pip install supabase python-dotenv requests
    script: |
      import os
      import json
      from supabase import create_client, Client
      
      # Configurar Supabase
      supabase_url = os.getenv('SUPABASE_URL')
      supabase_key = os.getenv('SUPABASE_ANON_KEY')
      supabase: Client = create_client(supabase_url, supabase_key)
      
      phone_number = "{{ inputs.phone }}"
      
      try:
          # Buscar histórico de conversa
          response = supabase.table('conversation_history').select('*').eq('phone_number', phone_number).order('created_at', desc=False).limit(10).execute()
          
          conversation_history = []
          
          for msg in response.data:
              conversation_history.append({
                  "role": msg["role"],
                  "content": msg["message"]
              })
          
          result = {
              "phone_number": phone_number,
              "history": conversation_history,
              "history_count": len(conversation_history),
              "status": "success"
          }
          
          print(json.dumps(result))
          
      except Exception as e:
          error_result = {
              "phone_number": phone_number,
              "history": [],
              "history_count": 0,
              "status": "error",
              "error": str(e)
          }
          print(json.dumps(error_result))

  # Task 2: Gerar resposta da IA usando plugin nativo OpenAI
  - id: generate-ai-response
    type: io.kestra.plugin.openai.ChatCompletion
    apiKey: "{{ secret('OPENAI_API_KEY') }}"
    model: "gpt-4o"
    messages:
      # System Message com persona de vendas
      - role: system
        content: |
          Você é um Especialista em Vendas da Serena Energia, uma empresa brasileira líder em energia solar.
          
          **IDENTIDADE E MISSÃO:**
          - Nome: Assistente Virtual Serena
          - Empresa: Serena Energia (energia solar no Brasil)
          - Objetivo: Qualificar leads interessados em energia solar
          - Tom: Profissional, consultivo, empático e orientado a resultados
          
          **PROCESSO DE QUALIFICAÇÃO:**
          1. Entender necessidades do cliente (conta de energia, consumo, imóvel)
          2. Identificar localização para verificar atendimento
          3. Coletar informações técnicas básicas
          4. Apresentar benefícios da energia solar
          5. Encaminhar para especialista quando qualificado
          
          **FERRAMENTAS DISPONÍVEIS:**
          - ask_knowledge_base: Para dúvidas técnicas sobre energia solar
          - query_serena_api: Para consultar planos e cobertura por cidade
          - save_and_fetch_conversation: Para gerenciar histórico de conversa
          
          **DIRETRIZES:**
          - Sempre pergunte sobre a conta de energia se não tiver essa informação
          - Identifique a cidade do cliente para verificar atendimento
          - Use as ferramentas quando necessário
          - Mantenha foco na qualificação e venda
          - Seja direto mas amigável
          
          **IMPORTANTE:**
          - Se o cliente mencionar conta de energia ou enviar foto/documento, use as ferramentas apropriadas
          - Para dúvidas técnicas, consulte a base de conhecimento
          - Para verificar atendimento, consulte a API Serena
          - Sempre salve as conversas importantes
          
          Histórico da conversa: {{ outputs['get-conversation-history'].vars.history | json }}
      
      # Mensagem atual do usuário
      - role: user
        content: "{{ inputs.message }}"
    
    functions:
      # Ferramenta 1: Base de Conhecimento (RAG)
      - name: "ask_knowledge_base"
        description: "Busca informações na base de conhecimento da Serena Energia sobre energia solar, instalação, benefícios, processos, etc."
        parameters:
          type: object
          properties:
            query:
              type: string
              description: "Pergunta ou termo para buscar na base de conhecimento"
          required: ["query"]
      
      # Ferramenta 2: API Serena (Planos e Cobertura)
      - name: "query_serena_api"
        description: "Consulta a API da Serena para verificar planos disponíveis, cobertura de atendimento por cidade e informações comerciais"
        parameters:
          type: object
          properties:
            city:
              type: string
              description: "Nome da cidade para consultar cobertura"
            state:
              type: string
              description: "Sigla do estado (ex: PE, SP, RJ)"
            action:
              type: string
              enum: ["get_plans", "check_coverage"]
              description: "Ação a ser executada - buscar planos ou verificar cobertura"
          required: ["city", "state", "action"]
      
      # Ferramenta 3: Gerenciar Conversa
      - name: "save_and_fetch_conversation"
        description: "Salva mensagens na conversa ou recupera histórico do Supabase"
        parameters:
          type: object
          properties:
            phone_number:
              type: string
              description: "Número de telefone do lead"
            action:
              type: string
              enum: ["save_message", "get_history"]
              description: "Ação - salvar mensagem ou recuperar histórico"
            message:
              type: string
              description: "Conteúdo da mensagem (quando action=save_message)"
            role:
              type: string
              enum: ["user", "assistant"]
              description: "Papel da mensagem (quando action=save_message)"
          required: ["phone_number", "action"]

  # Task 3: Switch para verificar se IA precisa usar ferramentas
  - id: check-function-call
    type: io.kestra.plugin.core.flow.Switch
    value: "{{ outputs['generate-ai-response'].choices[0].message.function_call is defined }}"
    cases:
      # Caso 1: IA quer usar uma ferramenta
      "true":
        - id: execute-function
          type: io.kestra.plugin.core.flow.Switch
          value: "{{ outputs['generate-ai-response'].choices[0].message.function_call.name }}"
          cases:
            # Executar ferramenta RAG
            "ask_knowledge_base":
              - id: run-rag-tool
                type: io.kestra.plugin.scripts.python.Script
                taskRunner:
                  type: io.kestra.plugin.scripts.runner.docker.Docker
                  image: "python:3.11-slim"
                beforeCommands:
                  - pip install langchain langchain-openai faiss-cpu python-dotenv requests
                script: |
                  import sys
                  import os
                  import json
                  import pickle
                  from langchain_openai import OpenAIEmbeddings
                  from langchain_community.vectorstores import FAISS
                  from langchain.schema import Document
                  
                  # Parse function arguments
                  function_args = json.loads('{{ outputs["generate-ai-response"].choices[0].message.function_call.arguments }}')
                  query = function_args.get("query", "")
                  
                  try:
                      # Configurar OpenAI
                      os.environ["OPENAI_API_KEY"] = "{{ secret('OPENAI_API_KEY') }}"
                      embeddings = OpenAIEmbeddings()
                      
                      # Carregar base de conhecimento (simulação - ajustar path conforme necessário)
                      # Em produção, isso seria carregado do volume Docker
                      knowledge_base = [
                          "A Serena Energia é especialista em energia solar fotovoltaica no Brasil.",
                          "Oferecemos instalação completa de sistemas de energia solar residencial e comercial.",
                          "Nossos sistemas reduzem até 95% da conta de energia elétrica.",
                          "Atendemos diversas cidades do Brasil com equipe técnica especializada.",
                          "O processo de instalação leva em média 1 a 3 dias úteis.",
                          "Oferecemos garantia de 25 anos nos painéis solares.",
                          "O investimento se paga entre 3 a 7 anos dependendo do consumo.",
                          "Trabalhamos com financiamento próprio e parcerias bancárias."
                      ]
                      
                      # Buscar resposta mais relevante (simulação simples)
                      best_match = ""
                      for item in knowledge_base:
                          if query.lower() in item.lower() or any(word in item.lower() for word in query.lower().split()):
                              best_match = item
                              break
                      
                      if not best_match:
                          best_match = "Informação não encontrada na base de conhecimento. Posso ajudar com outras dúvidas sobre energia solar."
                      
                      result = {
                          "success": True,
                          "data": {
                              "query": query,
                              "answer": best_match,
                              "source": "knowledge_base"
                          }
                      }
                      
                      print(json.dumps(result))
                      
                  except Exception as e:
                      error_result = {
                          "success": False,
                          "error": str(e),
                          "data": {
                              "query": query,
                              "answer": "Erro ao consultar base de conhecimento.",
                              "source": "error"
                          }
                      }
                      print(json.dumps(error_result))
            
            # Executar consulta API Serena
            "query_serena_api":
              - id: run-serena-api
                type: io.kestra.plugin.scripts.python.Script
                taskRunner:
                  type: io.kestra.plugin.scripts.runner.docker.Docker
                  image: "python:3.11-slim"
                beforeCommands:
                  - pip install requests python-dotenv
                script: |
                  import json
                  import requests
                  
                  # Parse function arguments
                  function_args = json.loads('{{ outputs["generate-ai-response"].choices[0].message.function_call.arguments }}')
                  city = function_args.get("city", "")
                  state = function_args.get("state", "")
                  action = function_args.get("action", "")
                  
                  try:
                      # Configurar API Serena
                      base_url = "https://partnership-service-staging.api.srna.co"
                      token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImQzNDBmZWEyLWM3ZTQtNGY1Ni1hYjdlLTAyMmE5ZDcwNTBiNiIsInBhcnRuZXJUeXBlIjoicGFydG5lcl9ncm91cCIsImlhdCI6MTc0NDgzNzEzOX0.YvvCD-I4GOSPmRduMoXit8Rw05c9ILoiCjhnPMgygO0"
                      
                      headers = {
                          "Authorization": f"Bearer {token}",
                          "Content-Type": "application/json"
                      }
                      
                      if action == "get_plans":
                          # Buscar planos para a cidade
                          url = f"{base_url}/distributors"
                          response = requests.get(url, headers=headers)
                          
                          if response.status_code == 200:
                              distributors = response.json()
                              
                              # Filtrar por cidade/estado
                              city_plans = []
                              for dist in distributors:
                                  if city.lower() in dist.get("name", "").lower() or state.upper() in dist.get("name", "").upper():
                                      city_plans.append({
                                          "distributor": dist.get("name"),
                                          "plans_count": len(dist.get("plans", [])),
                                          "plans": dist.get("plans", [])[:3]  # Primeiros 3 planos
                                      })
                              
                              result = {
                                  "success": True,
                                  "data": {
                                      "city": city,
                                      "state": state,
                                      "action": action,
                                      "plans_found": len(city_plans),
                                      "plans": city_plans
                                  }
                              }
                          else:
                              result = {
                                  "success": False,
                                  "error": f"API Error: {response.status_code}",
                                  "data": {
                                      "city": city,
                                      "state": state,
                                      "message": "Erro ao consultar planos disponíveis"
                                  }
                              }
                      
                      elif action == "check_coverage":
                          # Verificar cobertura (simulação baseada na API)
                          url = f"{base_url}/distributors"
                          response = requests.get(url, headers=headers)
                          
                          coverage = False
                          distributor_info = ""
                          
                          if response.status_code == 200:
                              distributors = response.json()
                              for dist in distributors:
                                  if city.lower() in dist.get("name", "").lower() or state.upper() in dist.get("name", "").upper():
                                      coverage = True
                                      distributor_info = dist.get("name", "")
                                      break
                          
                          result = {
                              "success": True,
                              "data": {
                                  "city": city,
                                  "state": state,
                                  "action": action,
                                  "coverage": coverage,
                                  "distributor": distributor_info,
                                  "message": f"{'Atendemos' if coverage else 'Não atendemos'} {city}/{state}"
                              }
                          }
                      
                      else:
                          result = {
                              "success": False,
                              "error": "Invalid action",
                              "data": {
                                  "city": city,
                                  "state": state,
                                  "message": "Ação inválida para API Serena"
                              }
                          }
                      
                      print(json.dumps(result))
                      
                  except Exception as e:
                      error_result = {
                          "success": False,
                          "error": str(e),
                          "data": {
                              "city": city,
                              "state": state,
                              "message": "Erro ao consultar API Serena"
                          }
                      }
                      print(json.dumps(error_result))
            
            # Executar salvar/buscar conversa
            "save_and_fetch_conversation":
              - id: run-conversation-manager
                type: io.kestra.plugin.scripts.python.Script
                taskRunner:
                  type: io.kestra.plugin.scripts.runner.docker.Docker
                  image: "python:3.11-slim"
                beforeCommands:
                  - pip install supabase python-dotenv
                script: |
                  import os
                  import json
                  from datetime import datetime
                  from supabase import create_client, Client
                  
                  # Parse function arguments
                  function_args = json.loads('{{ outputs["generate-ai-response"].choices[0].message.function_call.arguments }}')
                  phone_number = function_args.get("phone_number", "")
                  action = function_args.get("action", "")
                  message = function_args.get("message", "")
                  role = function_args.get("role", "")
                  
                  try:
                      # Configurar Supabase
                      supabase_url = os.getenv('SUPABASE_URL')
                      supabase_key = os.getenv('SUPABASE_ANON_KEY')
                      supabase: Client = create_client(supabase_url, supabase_key)
                      
                      if action == "save_message":
                          # Salvar mensagem
                          data = {
                              "phone_number": phone_number,
                              "message": message,
                              "role": role,
                              "created_at": datetime.now().isoformat()
                          }
                          
                          response = supabase.table('conversation_history').insert(data).execute()
                          
                          result = {
                              "success": True,
                              "data": {
                                  "phone_number": phone_number,
                                  "action": action,
                                  "message_saved": True,
                                  "role": role
                              }
                          }
                      
                      elif action == "get_history":
                          # Recuperar histórico
                          response = supabase.table('conversation_history').select('*').eq('phone_number', phone_number).order('created_at', desc=False).limit(10).execute()
                          
                          history = []
                          for msg in response.data:
                              history.append({
                                  "role": msg["role"],
                                  "message": msg["message"],
                                  "created_at": msg["created_at"]
                              })
                          
                          result = {
                              "success": True,
                              "data": {
                                  "phone_number": phone_number,
                                  "action": action,
                                  "history": history,
                                  "history_count": len(history)
                              }
                          }
                      
                      else:
                          result = {
                              "success": False,
                              "error": "Invalid action",
                              "data": {
                                  "phone_number": phone_number,
                                  "message": "Ação inválida para gerenciamento de conversa"
                              }
                          }
                      
                      print(json.dumps(result))
                      
                  except Exception as e:
                      error_result = {
                          "success": False,
                          "error": str(e),
                          "data": {
                              "phone_number": phone_number,
                              "message": "Erro ao gerenciar conversa"
                          }
                      }
                      print(json.dumps(error_result))

        # Após executar a ferramenta, fazer nova chamada para OpenAI com o resultado
        - id: generate-final-response
          type: io.kestra.plugin.openai.ChatCompletion
          apiKey: "{{ secret('OPENAI_API_KEY') }}"
          model: "gpt-4o"
          messages:
            # System message
            - role: system
              content: |
                Você é um Especialista em Vendas da Serena Energia. Você acabou de usar uma ferramenta para obter informações.
                Use o resultado da ferramenta para fornecer uma resposta útil e direcionada ao cliente.
                Mantenha o foco na qualificação e venda de energia solar.
            
            # Mensagem original do usuário
            - role: user
              content: "{{ inputs.message }}"
            
            # Chamada da função (para contexto)
            - role: assistant
              content: null
              function_call:
                name: "{{ outputs['generate-ai-response'].choices[0].message.function_call.name }}"
                arguments: "{{ outputs['generate-ai-response'].choices[0].message.function_call.arguments }}"
            
                         # Resultado da função
             - role: function
               name: "{{ outputs['generate-ai-response'].choices[0].message.function_call.name }}"
               content: "{{ outputs['run-rag-tool'].vars | json if outputs['run-rag-tool'] is defined else (outputs['run-serena-api'].vars | json if outputs['run-serena-api'] is defined else (outputs['run-conversation-manager'].vars | json if outputs['run-conversation-manager'] is defined else '{}')) }}"

      # Caso 2: IA não precisa de ferramentas, resposta direta
      "false":
        - id: use-direct-response
          type: io.kestra.plugin.core.log.Log
          message: "IA respondeu diretamente sem usar ferramentas"

  # Task 4: Salvar conversa no Supabase
  - id: save-conversation
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "python:3.11-slim"
    beforeCommands:
      - pip install supabase python-dotenv
    script: |
      import os
      import json
      from datetime import datetime
      from supabase import create_client, Client
      
      phone_number = "{{ inputs.phone }}"
      user_message = "{{ inputs.message }}"
      
             # Determinar resposta final da IA
       ai_response = "{{ outputs['generate-final-response'].choices[0].message.content if outputs['generate-final-response'] is defined else outputs['generate-ai-response'].choices[0].message.content }}"
      
      try:
          # Configurar Supabase
          supabase_url = os.getenv('SUPABASE_URL')
          supabase_key = os.getenv('SUPABASE_ANON_KEY')
          supabase: Client = create_client(supabase_url, supabase_key)
          
          # Salvar mensagem do usuário
          user_data = {
              "phone_number": phone_number,
              "message": user_message,
              "role": "user",
              "created_at": datetime.now().isoformat()
          }
          supabase.table('conversation_history').insert(user_data).execute()
          
          # Salvar resposta da IA
          ai_data = {
              "phone_number": phone_number,
              "message": ai_response,
              "role": "assistant",
              "created_at": datetime.now().isoformat()
          }
          supabase.table('conversation_history').insert(ai_data).execute()
          
          result = {
              "phone_number": phone_number,
              "user_message_saved": True,
              "ai_message_saved": True,
              "ai_response": ai_response,
              "status": "success"
          }
          
          print(json.dumps(result))
          
      except Exception as e:
          error_result = {
              "phone_number": phone_number,
              "user_message_saved": False,
              "ai_message_saved": False,
              "ai_response": ai_response,
              "status": "error",
              "error": str(e)
          }
          print(json.dumps(error_result))

  # Task 5: Enviar resposta via WhatsApp
  - id: send-whatsapp-response
    type: io.kestra.plugin.scripts.python.Script
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "python:3.11-slim"
    beforeCommands:
      - pip install requests
    script: |
      import json
      import requests
      
      phone_number = "{{ inputs.phone }}"
      
             # Determinar resposta final da IA
       message_content = "{{ outputs['generate-final-response'].choices[0].message.content if outputs['generate-final-response'] is defined else outputs['generate-ai-response'].choices[0].message.content }}"
      
      try:
          # Chamar serviço WhatsApp
          whatsapp_url = "http://whatsapp-sender:5000/whatsapp/send_text"
          
          payload = {
              "phone_number": phone_number,
              "message": message_content
          }
          
          response = requests.post(whatsapp_url, json=payload, timeout=30)
          
          if response.status_code == 200:
              result = {
                  "phone_number": phone_number,
                  "message_sent": True,
                  "message_content": message_content,
                  "whatsapp_response": response.json(),
                  "status": "success"
              }
          else:
              result = {
                  "phone_number": phone_number,
                  "message_sent": False,
                  "message_content": message_content,
                  "whatsapp_error": response.text,
                  "status": "whatsapp_error"
              }
          
          print(json.dumps(result))
          
      except Exception as e:
          error_result = {
              "phone_number": phone_number,
              "message_sent": False,
              "message_content": message_content,
              "status": "error",
              "error": str(e)
          }
          print(json.dumps(error_result))

outputs:
  - id: final_response
    type: STRING
    value: "{{ outputs['generate-final-response'].choices[0].message.content if outputs['generate-final-response'] is defined else outputs['generate-ai-response'].choices[0].message.content }}"
  - id: conversation_status
    type: STRING
    value: "{{ outputs['save-conversation'].vars.status }}"
  - id: whatsapp_status
    type: STRING
    value: "{{ outputs['send-whatsapp-response'].vars.status }}"
  - id: function_used
    type: STRING
    value: "{{ outputs['generate-ai-response'].choices[0].message.function_call.name if outputs['generate-ai-response'].choices[0].message.function_call is defined else 'none' }}"