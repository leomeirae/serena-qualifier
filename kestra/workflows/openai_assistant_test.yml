id: openai-assistant-test
namespace: serena.energia
description: "Workflow de Teste para Validação da Arquitetura OpenAI Assistant"

labels:
  version: "1.0.0"
  environment: "test"
  system: "serena-qualifier"
  framework: "openai_assistant"
  test_type: "validation"

# Trigger manual para testes
triggers:
  - id: test-webhook
    type: io.kestra.plugin.core.trigger.Webhook
    key: "openai_assistant_test"

inputs:
  - id: test_phone
    type: STRING
    required: false
    defaults: "+5511999999999"
  - id: test_message
    type: STRING
    required: false
    defaults: "Olá! Quero saber sobre energia solar"
  - id: test_scenario
    type: STRING
    required: false
    defaults: "simple"

tasks:
  # TESTE 1: Thread Manager
  - id: test-thread-manager
    type: io.kestra.plugin.scripts.python.Script
    description: "Teste do Thread Manager - Obter ou criar thread"
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
      fileHandlingStrategy: VOLUME
    env:
      TEST_PHONE: "{{ inputs.test_phone | default('+5511999999999') }}"
    script: |
      from dotenv import load_dotenv
      load_dotenv('/app/.env')
      
      import subprocess
      import json
      import os
      
      phone = os.getenv("TEST_PHONE")
      print(f"🧪 TESTE: Thread Manager - Phone: {phone}")
      
      try:
          result = subprocess.run([
              'python', '/app/scripts/thread_manager.py',
              '--phone-number', phone
          ], capture_output=True, text=True, cwd='/app')
          
          print(f"Return Code: {result.returncode}")
          print(f"STDOUT: {result.stdout}")
          if result.stderr:
              print(f"STDERR: {result.stderr}")
          
          test_result = {
              "success": result.returncode == 0,
              "phone": phone,
              "stdout": result.stdout
          }
          
      except Exception as e:
          print(f"❌ Erro: {str(e)}")
          test_result = {"success": False, "error": str(e)}
      
      print('::' + json.dumps({"outputs": {"test_result": test_result}}) + '::')

  # TESTE 2: OpenAI Handler - Adicionar Mensagem
  - id: test-openai-handler
    type: io.kestra.plugin.scripts.python.Script
    description: "Teste do OpenAI Handler - Adicionar mensagem à thread"
    runIf: "{{ outputs['test-thread-manager'].vars.test_result.success == true }}"
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
      fileHandlingStrategy: VOLUME
    env:
      TEST_MESSAGE: "{{ inputs.test_message | default(trigger.body.test_message | default('Olá! Quero saber sobre energia solar')) }}"
      THREAD_ID: "{{ outputs['test-thread-manager'].vars.thread_id }}"
    script: |
      from dotenv import load_dotenv
      load_dotenv('/app/.env')
      
      import subprocess
      import json
      import os
      
      message = os.getenv("TEST_MESSAGE")
      thread_id = os.getenv("THREAD_ID")
      
      print(f"🧪 TESTE 2: OpenAI Handler - Thread: {thread_id}")
      print(f"💬 Mensagem: {message}")
      
      try:
          # Executar openai_handler.py para adicionar mensagem
          result = subprocess.run([
              'python', '/app/scripts/openai_handler.py',
              '--action', 'add_message',
              '--thread-id', thread_id,
              '--message', message
          ], capture_output=True, text=True, cwd='/app')
          
          print(f"📤 Return Code: {result.returncode}")
          print(f"📤 STDOUT: {result.stdout}")
          if result.stderr:
              print(f"📤 STDERR: {result.stderr}")
          
          test_result = {
              "test": "openai_handler_add_message",
              "success": result.returncode == 0,
              "thread_id": thread_id,
              "message": message,
              "stdout": result.stdout,
              "stderr": result.stderr
          }
          
      except Exception as e:
          print(f"❌ Erro no teste: {str(e)}")
          test_result = {
              "test": "openai_handler_add_message",
              "success": False,
              "error": str(e),
              "thread_id": thread_id
          }
      
      print('::' + json.dumps({"outputs": {"handler_test": test_result}}) + '::')

  # TESTE 3: Criar Run
  - id: test-create-run
    type: io.kestra.plugin.scripts.python.Script
    description: "Teste de Criação de Run"
    runIf: "{{ outputs['test-openai-handler'].vars.handler_test.success == true }}"
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
      fileHandlingStrategy: VOLUME
    env:
      THREAD_ID: "{{ outputs['test-thread-manager'].vars.thread_id }}"
      ASSISTANT_ID: "{{ env.OPENAI_ASSISTANT_ID }}"
    script: |
      from dotenv import load_dotenv
      load_dotenv('/app/.env')
      
      import subprocess
      import json
      import os
      
      thread_id = os.getenv("THREAD_ID")
      assistant_id = os.getenv("ASSISTANT_ID")
      
      print(f"🧪 TESTE 3: Criar Run - Thread: {thread_id}")
      print(f"🤖 Assistant: {assistant_id}")
      
      try:
          # Executar openai_handler.py para criar run
          result = subprocess.run([
              'python', '/app/scripts/openai_handler.py',
              '--action', 'create_run',
              '--thread-id', thread_id,
              '--assistant-id', assistant_id
          ], capture_output=True, text=True, cwd='/app')
          
          print(f"📤 Return Code: {result.returncode}")
          print(f"📤 STDOUT: {result.stdout}")
          if result.stderr:
              print(f"📤 STDERR: {result.stderr}")
          
          # Parse do run_id
          run_id = None
          if result.returncode == 0:
              lines = result.stdout.strip().split('\n')
              for line in lines:
                  if line.startswith('::') and line.endswith('::'):
                      output_data = json.loads(line[2:-2])
                      run_id = output_data.get('vars', {}).get('run_id')
                      break
          
          test_result = {
              "test": "create_run",
              "success": result.returncode == 0,
              "thread_id": thread_id,
              "assistant_id": assistant_id,
              "run_id": run_id,
              "stdout": result.stdout,
              "stderr": result.stderr
          }
          
      except Exception as e:
          print(f"❌ Erro no teste: {str(e)}")
          test_result = {
              "test": "create_run",
              "success": False,
              "error": str(e),
              "thread_id": thread_id
          }
      
      print('::' + json.dumps({"outputs": {"run_test": test_result}}) + '::')

  # TESTE 4: Verificar Status (com polling simples)
  - id: test-check-status
    type: io.kestra.plugin.scripts.python.Script
    description: "Teste de Verificação de Status com Polling"
    runIf: "{{ outputs['test-create-run'].vars.run_test.success == true }}"
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
      fileHandlingStrategy: VOLUME
    env:
      THREAD_ID: "{{ outputs['test-thread-manager'].vars.thread_id }}"
      RUN_ID: "{{ outputs['test-create-run'].vars.run_test.run_id }}"
    script: |
      from dotenv import load_dotenv
      load_dotenv('/app/.env')
      
      import subprocess
      import json
      import os
      import time
      
      thread_id = os.getenv("THREAD_ID")
      run_id = os.getenv("RUN_ID")
      
      print(f"🧪 TESTE 4: Check Status - Run: {run_id}")
      
      try:
          # Polling simples (máximo 5 tentativas)
          max_attempts = 5
          for attempt in range(max_attempts):
              print(f"🔄 Tentativa {attempt + 1}/{max_attempts}")
              
              result = subprocess.run([
                  'python', '/app/scripts/openai_handler.py',
                  '--action', 'check_status',
                  '--thread-id', thread_id,
                  '--run-id', run_id
              ], capture_output=True, text=True, cwd='/app')
              
              print(f"📤 Return Code: {result.returncode}")
              print(f"📤 STDOUT: {result.stdout}")
              
              if result.returncode == 0:
                  # Parse do status
                  lines = result.stdout.strip().split('\n')
                  for line in lines:
                      if line.startswith('::') and line.endswith('::'):
                          output_data = json.loads(line[2:-2])
                          status = output_data.get('vars', {}).get('status')
                          print(f"📊 Status: {status}")
                          
                          if status in ['completed', 'failed', 'cancelled', 'expired']:
                              print(f"✅ Status final: {status}")
                              break
                  
                  if status in ['completed', 'failed', 'cancelled', 'expired']:
                      break
              
              if attempt < max_attempts - 1:
                  time.sleep(3)  # Aguarda 3 segundos
          
          test_result = {
              "test": "check_status",
              "success": result.returncode == 0,
              "thread_id": thread_id,
              "run_id": run_id,
              "final_status": status if 'status' in locals() else 'unknown',
              "attempts": attempt + 1,
              "stdout": result.stdout,
              "stderr": result.stderr
          }
          
      except Exception as e:
          print(f"❌ Erro no teste: {str(e)}")
          test_result = {
              "test": "check_status",
              "success": False,
              "error": str(e),
              "run_id": run_id
          }
      
      print('::' + json.dumps({"outputs": {"status_test": test_result}}) + '::')

  # TESTE 5: Obter Resposta Final
  - id: test-get-response
    type: io.kestra.plugin.scripts.python.Script
    description: "Teste de Obtenção da Resposta Final"
    runIf: "{{ outputs['test-check-status'].vars.status_test.final_status == 'completed' }}"
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: "serena-runner:latest"
      pullPolicy: "NEVER"
      networkMode: "serena-qualifier_kestra-network"
      fileHandlingStrategy: VOLUME
    env:
      THREAD_ID: "{{ outputs['test-thread-manager'].vars.thread_id }}"
    script: |
      from dotenv import load_dotenv
      load_dotenv('/app/.env')
      
      import subprocess
      import json
      import os
      
      thread_id = os.getenv("THREAD_ID")
      
      print(f"🧪 TESTE 5: Get Response - Thread: {thread_id}")
      
      try:
          result = subprocess.run([
              'python', '/app/scripts/openai_handler.py',
              '--action', 'get_response',
              '--thread-id', thread_id
          ], capture_output=True, text=True, cwd='/app')
          
          print(f"📤 Return Code: {result.returncode}")
          print(f"📤 STDOUT: {result.stdout}")
          if result.stderr:
              print(f"📤 STDERR: {result.stderr}")
          
          # Parse da resposta
          response_text = None
          if result.returncode == 0:
              lines = result.stdout.strip().split('\n')
              for line in lines:
                  if line.startswith('::') and line.endswith('::'):
                      output_data = json.loads(line[2:-2])
                      response_text = output_data.get('vars', {}).get('response')
                      break
          
          test_result = {
              "test": "get_response",
              "success": result.returncode == 0,
              "thread_id": thread_id,
              "response": response_text,
              "stdout": result.stdout,
              "stderr": result.stderr
          }
          
          if response_text:
              print(f"🤖 Resposta do Assistant: {response_text[:200]}...")
          
      except Exception as e:
          print(f"❌ Erro no teste: {str(e)}")
          test_result = {
              "test": "get_response",
              "success": False,
              "error": str(e),
              "thread_id": thread_id
          }
      
      print('::' + json.dumps({"outputs": {"response_test": test_result}}) + '::')

outputs:
  - id: test_summary
    type: JSON
    value: |
      {
        "thread_manager_test": {{ outputs['test-thread-manager'].vars.test_result | json }},
        "handler_test": {{ outputs['test-openai-handler'].vars.handler_test | json }},
        "run_test": {{ outputs['test-create-run'].vars.run_test | json }},
        "status_test": {{ outputs['test-check-status'].vars.status_test | json }},
        "response_test": {{ outputs['test-get-response'].vars.response_test | json }},
        "overall_success": {{ (outputs['test-get-response'].vars.response_test.success == true) | default(false) }}
      }
  - id: success
    type: BOOLEAN
    value: "{{ outputs['test-thread-manager'].vars.test_result.success == true }}" 