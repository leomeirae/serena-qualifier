id: 2_sdr_conversation_flow
namespace: serena.production
description: "Serena SDR - Agente Virtual de Pr√©-vendas (S√≠lvia) - Workflow principal de conversa√ß√£o"

triggers:
  - id: whatsapp_sdr_trigger
    type: io.kestra.plugin.core.trigger.Webhook
    key: converse_sdr_silvia
    description: "Webhook para mensagens WhatsApp do agente SDR"

variables:
  # Configura√ß√µes IA
  ai_model: "gpt-4o"
  max_tokens: 1500
  temperature: 0.5
  
  # Configura√ß√µes de Performance
  context_size_limit: 102400
  max_retries: 3
  request_timeout: 30

  # URLs dos MCP Servers
  supabase_mcp_url: "http://supabase-mcp-server:3000"
  serena_mcp_url: "http://serena-mcp-server:3002"
  whatsapp_mcp_url: "http://whatsapp-mcp-server:3003"

tasks:
  # FASE 1: LOG INICIAL E VALIDA√á√ÉO
  - id: log_inicial
    type: io.kestra.plugin.core.log.Log
    description: "Registra in√≠cio do processamento da mensagem"
    message: |
      [SDR TRIGGER] Webhook recebido
      ================================================
      Phone: {{ trigger.body.phone ?? 'N/A' }}
      Lead ID: {{ trigger.body.lead_id ?? 'N/A' }}
      Message: {{ trigger.body.message ?? 'N/A' }}
      Message Type: {{ trigger.body.type ?? 'text' }}
      Timestamp: {{ now() }}
      
      [DEBUG] Workflow iniciado com sucesso!

  # FASE 2: EXTRA√á√ÉO DE MEDIA_ID
  - id: extract_media_id
    type: io.kestra.plugin.scripts.python.Script
    description: "Extrai o media_id do payload WhatsApp para processamento de imagens"
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: python:3.11-slim
      networkMode: coolify
    env:
      PHONE_NUMBER: "{{ trigger.body.phone ?? 'N/A' }}"
      LEAD_ID: "{{ trigger.body.lead_id ?? 'N/A' }}"
      MESSAGE_TYPE: "{{ trigger.body.type ?? 'text' }}"
      MESSAGE_TEXT: "{{ trigger.body.message ?? '' }}"
    script: |
      import json
      import os
      from kestra import Kestra
      
      # Obter dados do trigger de forma segura
      try:
          # Tentar obter dados do trigger
          phone = os.environ.get('PHONE_NUMBER', '')
          lead_id = os.environ.get('LEAD_ID', '')
          message_type = os.environ.get('MESSAGE_TYPE', 'text')
          message_text = os.environ.get('MESSAGE_TEXT', '')
          
          print(f"[DEBUG] Phone: {phone}")
          print(f"[DEBUG] Lead ID: {lead_id}")
          print(f"[DEBUG] Message Type: {message_type}")
          print(f"[DEBUG] Message Text: {message_text}")
          
          # Para este teste, vamos usar um media_id vazio
          media_id = ""
          print(f"[DEBUG] Media ID final extra√≠do: '{media_id}'")
          
          Kestra.outputs({
              'media_id': media_id,
              'phone': phone,
              'lead_id': lead_id,
              'message_type': message_type,
              'message_text': message_text
          })
          
      except Exception as e:
          print(f"[ERROR] Erro ao extrair media_id: {str(e)}")
          Kestra.outputs({
              'media_id': '',
              'phone': '',
              'lead_id': '',
              'message_type': 'text',
              'message_text': ''
          })

  # FASE 3: CLASSIFICA√á√ÉO DE M√çDIA (NOVO)
  - id: classify_media
    type: io.kestra.plugin.scripts.python.Script
    description: "Classifica se a mensagem √© imagem ou texto usando classify_media.py"
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: python:3.11-slim
      networkMode: coolify
    env:
      MEDIA_ID: "{{ outputs.extract_media_id.vars.media_id }}"
      MESSAGE_TYPE: "{{ outputs.extract_media_id.vars.message_type }}"
      MESSAGE_TEXT: "{{ outputs.extract_media_id.vars.message_text }}"
    inputFiles:
      scripts/sdr/classify_media.py: "{{ read('scripts/sdr/classify_media.py') }}"
    script: |
      import os
      import json
      from kestra import Kestra
      from scripts.sdr.classify_media import classify_media_content
      
      try:
          media_id = os.environ.get('MEDIA_ID', '')
          message_type = os.environ.get('MESSAGE_TYPE', 'text')
          message_text = os.environ.get('MESSAGE_TEXT', '')
          
          # Classificar m√≠dia
          result = classify_media_content(
              media_id=media_id,
              message_type=message_type,
              message_text=message_text
          )
          
          Kestra.outputs({
              'is_image': result.get('is_image', False),
              'confidence': result.get('confidence', 0.0),
              'extracted_text': result.get('extracted_text', ''),
              'media_id': media_id,
              'message_type': message_type
          })
          
      except Exception as e:
          print(f"[ERROR] Erro na classifica√ß√£o de m√≠dia: {str(e)}")
          Kestra.outputs({
              'is_image': False,
              'confidence': 0.0,
              'extracted_text': '',
              'media_id': media_id,
              'message_type': message_type
          })

  # FASE 4: BUSCAR DADOS DO LEAD NO SUPABASE
  - id: get_lead_data
    type: io.kestra.plugin.core.http.Request
    description: "Busca dados do lead no Supabase via MCP (JSON-RPC)"
    uri: "{{ vars.supabase_mcp_url }}/mcp"
    method: POST
    headers:
      Content-Type: "application/json"
    body: |
      {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "tools/call",
        "params": {
          "name": "execute_sql",
          "arguments": {
            "query": "SELECT * FROM leads WHERE phone_number = '{{ outputs.extract_media_id.vars.phone }}'"
          }
        }
      }
    allowFailure: true

  # FASE 5: PROCESSAMENTO DO AGENTE IA
  - id: run_agent
    type: io.kestra.plugin.scripts.python.Script
    description: "Executa o agente conversacional com OpenAI Function Calling"
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: kestra-agent:latest
      networkMode: coolify
    env:
      # üîê Chaves Secretas (API)
      OPENAI_API_KEY: "{{ secret('OPENAI_API_KEY') }}"
      SERENA_API_TOKEN: "{{ secret('SERENA_API_TOKEN') }}"
      WHATSAPP_API_TOKEN: "{{ secret('WHATSAPP_API_TOKEN') }}"

      # üß† Configura√ß√£o da Mensagem
      USER_MESSAGE: "{{ outputs.extract_media_id.vars.message_text }}"
      PHONE_NUMBER: "{{ outputs.extract_media_id.vars.phone }}"
      MESSAGE_TYPE: "{{ outputs.extract_media_id.vars.message_type }}"
      MEDIA_ID: "{{ outputs.extract_media_id.vars.media_id | default('') }}"
      LEAD_ID: "{{ outputs.extract_media_id.vars.lead_id }}"
      IS_IMAGE: "{{ outputs.classify_media.vars.is_image | default(false) }}"
      EXTRACTED_TEXT: "{{ outputs.classify_media.vars.extracted_text | default('') }}"

      # üîó Dados do Lead (do Supabase)
      LEAD_DATA: "{{ outputs.get_lead_data.body | default('{}') }}"

      # üåê Servi√ßos MCP
      SUPABASE_MCP_URL: "{{ vars.supabase_mcp_url }}"
      SERENA_MCP_URL: "{{ vars.serena_mcp_url }}"
      WHATSAPP_MCP_URL: "{{ vars.whatsapp_mcp_url }}"

      # ‚öôÔ∏è Configura√ß√µes IA
      AI_MODEL: "{{ vars.ai_model }}"
      MAX_TOKENS: "{{ vars.max_tokens }}"
      TEMPERATURE: "{{ vars.temperature }}"
    inputFiles:
      scripts/sdr/ai_sdr_agent.py: "{{ read('scripts/sdr/ai_sdr_agent.py') }}"
      scripts/sdr/agent_tools/__init__.py: "{{ read('scripts/sdr/agent_tools/__init__.py') }}"
      scripts/sdr/agent_tools/supabase_tools.py: "{{ read('scripts/sdr/agent_tools/supabase_tools.py') }}"
      scripts/sdr/agent_tools/serena_tools.py: "{{ read('scripts/sdr/agent_tools/serena_tools.py') }}"
      scripts/sdr/agent_tools/whatsapp_tools.py: "{{ read('scripts/sdr/agent_tools/whatsapp_tools.py') }}"
      scripts/sdr/agent_tools/ocr_tools.py: "{{ read('scripts/sdr/agent_tools/ocr_tools.py') }}"
      scripts/sdr/utils/__init__.py: "{{ read('scripts/sdr/utils/__init__.py') }}"
      scripts/sdr/utils/config.py: "{{ read('scripts/sdr/utils/config.py') }}"
      scripts/sdr/utils/logger.py: "{{ read('scripts/sdr/utils/logger.py') }}"
      scripts/sdr/utils/mcp_client.py: "{{ read('scripts/sdr/utils/mcp_client.py') }}"
    script: |
      import sys
      import os
      import json
      import logging
      from kestra import Kestra
      
      # Configurar logging
      logging.basicConfig(level=logging.INFO)
      logger = logging.getLogger(__name__)
      
      try:
          # Importar o agente
          from scripts.sdr.ai_sdr_agent import SerenaSDRAgent
          
          # Obter dados do ambiente
          phone_number = os.environ.get('PHONE_NUMBER')
          user_message = os.environ.get('USER_MESSAGE')
          message_type = os.environ.get('MESSAGE_TYPE', 'text')
          media_id = os.environ.get('MEDIA_ID', '')
          lead_id = os.environ.get('LEAD_ID')
          is_image = os.environ.get('IS_IMAGE', 'false').lower() == 'true'
          extracted_text = os.environ.get('EXTRACTED_TEXT', '')
          lead_data = json.loads(os.environ.get('LEAD_DATA', '{}'))
          
          # Log detalhado para debug
          logger.info(f"[DEBUG] PHONE_NUMBER: '{phone_number}'")
          logger.info(f"[DEBUG] MESSAGE_TYPE: '{message_type}'")
          logger.info(f"[DEBUG] MEDIA_ID: '{media_id}'")
          logger.info(f"[DEBUG] IS_IMAGE: '{is_image}'")
          logger.info(f"[DEBUG] EXTRACTED_TEXT: '{extracted_text}'")
          logger.info(f"[DEBUG] LEAD_ID: '{lead_id}'")
          logger.info(f"[DEBUG] LEAD_DATA: {json.dumps(lead_data, indent=2)}")
          
          # Criar inst√¢ncia do agente
          agent = SerenaSDRAgent()
          
          # Executar agente
          logger.info(f"[AI] Processando mensagem para {phone_number}: {user_message[:50]}...")
          result = agent.run_agent(
              lead_id=lead_id,
              user_message=user_message,
              message_type=message_type,
              media_id=media_id,
              is_image=is_image,
              extracted_text=extracted_text,
              lead_data=lead_data
          )
          
          response = result.get('response', 'Desculpe, ocorreu um erro interno.')
          logger.info(f"[AI] Resposta gerada: {len(response)} chars")
          
          Kestra.outputs({
              'response': response,
              'success': True,
              'lead_id': lead_id,
              'phone_number': phone_number
          })
          
      except Exception as e:
          logger.error(f"[ERROR] Erro no processamento IA: {str(e)}")
          fallback_response = "Ol√°! Sou a S√≠lvia da Serena Energia. üòä No momento estou com dificuldades t√©cnicas. Por favor, tente novamente em alguns minutos ou entre em contato conosco pelo nosso canal oficial. Obrigada pela compreens√£o!"
          Kestra.outputs({
              'response': fallback_response,
              'success': False,
              'error': str(e),
              'lead_id': lead_id,
              'phone_number': phone_number
          })

  # FASE 6: ENVIO DA RESPOSTA VIA WHATSAPP
  - id: send_whatsapp_message
    type: io.kestra.plugin.core.http.Request
    description: "Envia resposta do agente via WhatsApp MCP (JSON-RPC)"
    uri: "{{ vars.whatsapp_mcp_url }}/mcp"
    method: POST
    headers:
      Content-Type: "application/json"
    body: |
      {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "tools/call",
        "params": {
          "name": "sendTextMessage",
          "arguments": {
            "to": "{{ outputs.extract_media_id.vars.phone }}",
            "message": "{{ outputs.run_agent.vars.response }}"
          }
        }
      }
    allowFailure: true

  # FASE 7: LOG DE SUCESSO
  - id: log_success
    type: io.kestra.plugin.core.log.Log
    description: "Registra sucesso do processamento"
    runIf: "{{ outputs.run_agent.vars.success == true }}"
    message: |
      ‚úÖ SDR PROCESSAMENTO CONCLU√çDO COM SUCESSO
      ================================================
      Lead ID: {{ outputs.extract_media_id.vars.lead_id }}
      Phone: {{ outputs.extract_media_id.vars.phone }}
      Message: {{ outputs.extract_media_id.vars.message_text[:100] }}...
      Is Image: {{ outputs.classify_media.vars.is_image }}
      Response Length: {{ outputs.run_agent.vars.response | length }} chars
      WhatsApp Status: {{ outputs.send_whatsapp_message.vars.statusCode | default('PENDING') }}
      Timestamp: {{ now() }}

  # FASE 8: WAIT 2 HORAS PARA FOLLOW-UP
  - id: wait_2h
    type: io.kestra.plugin.scripts.python.Script
    description: "Aguarda 2 horas antes de verificar resposta"
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: python:3.11-slim
      networkMode: coolify
    runIf: "{{ outputs.run_agent.vars.success == true }}"
    script: |
      import time
      import logging
      from kestra import Kestra
      
      logging.basicConfig(level=logging.INFO)
      logger = logging.getLogger(__name__)
      
      logger.info("Iniciando aguardo de 2 horas para follow-up...")
      
      # Aguarda 2 horas (7200 segundos)
      time.sleep(7200)
      
      logger.info("Aguardo conclu√≠do. Prosseguindo para follow-up...")
      
      Kestra.outputs({
          'wait_completed': True,
          'wait_duration': 'PT2H'
      })

  # FASE 9: FOLLOW-UP AP√ìS 2 HORAS
  - id: follow_up_if_needed
    type: io.kestra.plugin.scripts.python.Script
    description: "Envia follow-up ap√≥s 2 horas sem resposta"
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: kestra-agent:latest
      networkMode: coolify
    runIf: "{{ outputs.run_agent.vars.success == true }}"
    env:
      OPENAI_API_KEY: "{{ secret('OPENAI_API_KEY') }}"
      PHONE_NUMBER: "{{ outputs.extract_media_id.vars.phone }}"
      LEAD_ID: "{{ outputs.extract_media_id.vars.lead_id }}"
      LEAD_DATA: "{{ outputs.get_lead_data.body | default('{}') }}"
      SUPABASE_MCP_URL: "{{ vars.supabase_mcp_url }}"
      SERENA_MCP_URL: "{{ vars.serena_mcp_url }}"
      WHATSAPP_MCP_URL: "{{ vars.whatsapp_mcp_url }}"
    inputFiles:
      scripts/sdr/follow_up_agent.py: "{{ read('scripts/sdr/follow_up_agent.py') }}"
    script: |
      import os
      import json
      import logging
      from kestra import Kestra
      
      logging.basicConfig(level=logging.INFO)
      logger = logging.getLogger(__name__)
      
      try:
          from scripts.sdr.follow_up_agent import FollowUpAgent
          
          phone_number = os.environ.get('PHONE_NUMBER')
          lead_id = os.environ.get('LEAD_ID')
          lead_data = json.loads(os.environ.get('LEAD_DATA', '{}'))
          
          logger.info(f"[FOLLOW-UP] Gerando lembrete para {phone_number}")
          
          agent = FollowUpAgent()
          result = agent.generate_follow_up(
              lead_id=lead_id,
              phone_number=phone_number,
              lead_data=lead_data
          )
          
          Kestra.outputs({
              'follow_up_sent': True,
              'follow_up_message': result.get('message', ''),
              'phone_number': phone_number
          })
          
      except Exception as e:
          logger.error(f"[ERROR] Erro no follow-up: {str(e)}")
          Kestra.outputs({
              'follow_up_sent': False,
              'error': str(e)
          })

  # FASE 10: LOG FINAL
  - id: log_final
    type: io.kestra.plugin.core.log.Log
    description: "Log final do workflow"
    message: |
      [SDR WORKFLOW FINALIZADO]
      ================================================
      Lead ID: {{ outputs.extract_media_id.vars.lead_id }}
      Phone: {{ outputs.extract_media_id.vars.phone }}
      Agent Success: {{ outputs.run_agent.vars.success | default('N/A') }}
      WhatsApp Sent: {{ outputs.send_whatsapp_message.vars.statusCode | default('N/A') }}
      Follow-up Sent: {{ outputs.follow_up_if_needed.vars.follow_up_sent | default('N/A') }}
      Duration: {{ execution.duration }}
      Timestamp: {{ now() }}

# Error Handling Global
errors:
  - id: global_error_handler
    type: io.kestra.plugin.core.log.Log
    description: "Handler global de erros"
    level: ERROR
    message: |
      ‚ùå ERRO GLOBAL NO WORKFLOW SDR
      ================================================
      Lead ID: N/A
      Phone: N/A
      Error: {{ execution.error }}
      Task: {{ execution.taskRunId }}
      Timestamp: {{ now() }}
      
      Enviando mensagem de fallback para o lead... 

  - id: send_fallback_message
    type: io.kestra.plugin.core.http.Request
    description: "Envia mensagem de fallback em caso de erro"
    uri: "{{ vars.whatsapp_mcp_url }}/mcp"
    method: POST
    headers:
      Content-Type: "application/json"
    body: |
      {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "tools/call",
        "params": {
          "name": "sendTextMessage",
          "arguments": {
            "to": "+5581997498268",
            "message": "Desculpe, tivemos um problema t√©cnico. Retornarei em breve. üòä"
          }
        }
      } 